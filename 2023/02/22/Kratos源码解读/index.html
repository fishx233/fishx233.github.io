<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="kratos源码分析"><meta name="keywords" content=""><meta name="author" content="fish"><meta name="copyright" content="fish"><title>kratos源码分析 | fish</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.3.0'
} </script><meta name="generator" content="Hexo 6.3.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%86%E5%A4%87"><span class="toc-number">1.</span> <span class="toc-text"> 准备</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text"> 目录结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1"><span class="toc-number">3.</span> <span class="toc-text"> 启动服务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text"> 流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">3.2.</span> <span class="toc-text"> 代码分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">4.</span> <span class="toc-text"> 中间件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6"><span class="toc-number">5.</span> <span class="toc-text"> 组件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">5.1.</span> <span class="toc-text"> 序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#json"><span class="toc-number">5.1.1.</span> <span class="toc-text"> JSON</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.1.2.</span> <span class="toc-text"> 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.3.</span> <span class="toc-text"> 方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE"><span class="toc-number">5.2.</span> <span class="toc-text"> 元数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">5.3.</span> <span class="toc-text"> 错误处理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text"> 奇奇怪怪的算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95-p2c"><span class="toc-number">6.1.</span> <span class="toc-text"> 负载均衡算法 P2C</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95-wrr"><span class="toc-number">6.2.</span> <span class="toc-text"> 负载均衡算法 WRR</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%86%E8%8A%82%E8%A1%A5%E5%85%85"><span class="toc-number">7.</span> <span class="toc-text"> 细节补充</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E4%BC%A0%E9%80%92"><span class="toc-number">7.1.</span> <span class="toc-text"> 超时传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%8A%82%E7%82%B9%E4%BF%A1%E6%81%AF%E9%87%87%E9%9B%86"><span class="toc-number">7.2.</span> <span class="toc-text"> 负载均衡节点信息采集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E4%BF%A1%E6%81%AF%E4%BB%8E%E5%93%AA%E6%9D%A5"><span class="toc-number">7.2.1.</span> <span class="toc-text"> 节点信息从哪来</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%8A%82%E7%82%B9%E4%BF%A1%E6%81%AF%E7%BB%93%E6%9E%84"><span class="toc-number">7.2.2.</span> <span class="toc-text"> 负载均衡节点信息结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">8.</span> <span class="toc-text"> 其他参考资料</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/media/44b726fcde934f76ac03a9a019fbb060.jpeg"></div><div class="author-info__name text-center">fish</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">7</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">4</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/media/101485281_p0_master1200.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">fish</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">kratos源码分析</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-02-22</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Go/">Go</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><meta name="referrer" content="no-referrer" />
<a name="QWhhm"></a>
<h1 id="准备"><a class="markdownIt-Anchor" href="#准备"></a> 准备</h1>
<ul>
<li>代码基于v2.5.4<br />
<a name="sx6oE"></a></li>
</ul>
<h1 id="目录结构"><a class="markdownIt-Anchor" href="#目录结构"></a> 目录结构</h1>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── api # api目前，存放api proto文件，目前主要放传输的metadata proto定义</span><br><span class="line">├── cmd # 工具组件，主要包含kratos, protoc-gen-go-errors, protoc-gen-go-http等命令工具，代码生成</span><br><span class="line">├── config # 配置组件，包含Config组件的接口定义和基本的env和file config实现</span><br><span class="line">├── contrib # 三方组件，包含kratos支持的三方组件实现，包含服务注册服务发现组件(etcd, zk等)，配置组件(apollo，nacos等)等等</span><br><span class="line">│   ├── config # 三方配置组件</span><br><span class="line">│   ├── encoding # 三方序列化组件 </span><br><span class="line">│   ├── log # 三方日志组件</span><br><span class="line">│   ├── metrics # 三方指标组件</span><br><span class="line">│   ├── opensergo # OpenSergo</span><br><span class="line">│   ├── polaris # 北极星</span><br><span class="line">│   └── registry # 三方服务注册服务组件</span><br><span class="line">├── docs # 文档</span><br><span class="line">├── encoding # 序列化组件，包含基本的form，json，proto，yaml，xml的解析</span><br><span class="line">├── errors # 自定义error实现</span><br><span class="line">├── internal # 内部实现方法</span><br><span class="line">├── log # 日志组件接口定义，基本操作如敏感词过滤，高级日志助手的封装</span><br><span class="line">├── metadata # metadata元数据操作方法</span><br><span class="line">├── metrics # 指标组件接口定义</span><br><span class="line">├── middleware # 中间件</span><br><span class="line">├── registry # 服务注册发现组件接口定义</span><br><span class="line">├── selector # 路由和负载均衡的接口定义和内置实现</span><br><span class="line">├── third_party # 三方包，例如三方的proto文件</span><br><span class="line">└── transport # 协议实现，目前支持http和grpc</span><br></pre></td></tr></table></figure>
<p><a name="ipMmN"></a></p>
<h1 id="启动服务"><a class="markdownIt-Anchor" href="#启动服务"></a> 启动服务</h1>
<p><a name="a1VnJ"></a></p>
<h2 id="流程"><a class="markdownIt-Anchor" href="#流程"></a> 流程</h2>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/1487474/1691816746471-d407ff6a-c917-4b0b-a938-be6daf467eae.png#averageHue=%231c1b18&amp;clientId=u59b681d6-7a1d-4&amp;from=paste&amp;id=u08d3718c&amp;originHeight=1122&amp;originWidth=878&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u868a05c9-e431-4aeb-893f-ba3195e47e9&amp;title=" alt="" /><br /><strong>ps：偷的图</strong><br />
<a name="bTHQN"></a></p>
<h2 id="代码分析"><a class="markdownIt-Anchor" href="#代码分析"></a> 代码分析</h2>
<p><strong>初始化</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个核心的kratos app，管理服务server的生命周期，可以配置Server Start,Stop生命周期对应的拦截器；实例的基本信息</span></span><br><span class="line">App := kratos.New(</span><br><span class="line">    kratos.ID(id),</span><br><span class="line">    kratos.Name(Name),</span><br><span class="line">    kratos.Version(Version),</span><br><span class="line">    kratos.Metadata(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;&#125;),</span><br><span class="line">    kratos.Logger(logger),</span><br><span class="line">    kratos.Server(</span><br><span class="line">        hs,</span><br><span class="line">    ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><strong>启动</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// run之后就会把对应的服务启用起来，监听对应端口，run是一个阻塞的方法</span></span><br><span class="line">App.Run()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *App)</span></span> Run() <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 创建服务注册实例，包含server的一些元数据信息，主要在服务注册发现中使用，端点，版本号，id，version啥的</span></span><br><span class="line">    instance, err := a.buildInstance()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    a.mu.Lock()</span><br><span class="line">    a.instance = instance</span><br><span class="line">    a.mu.Unlock()</span><br><span class="line">    sctx := NewContext(a.ctx, a)</span><br><span class="line">    <span class="comment">// 使用errgroup来启动所有server</span></span><br><span class="line">    eg, ctx := errgroup.WithContext(sctx)</span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    <span class="comment">// 执行拦截器</span></span><br><span class="line">    <span class="keyword">for</span> _, fn := <span class="keyword">range</span> a.opts.beforeStart &#123;</span><br><span class="line">        <span class="keyword">if</span> err = fn(sctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启用所有server</span></span><br><span class="line">    <span class="keyword">for</span> _, srv := <span class="keyword">range</span> a.opts.servers &#123;</span><br><span class="line">        srv := srv</span><br><span class="line">        eg.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">            &lt;-ctx.Done() <span class="comment">// wait for stop signal</span></span><br><span class="line">            stopCtx, cancel := context.WithTimeout(NewContext(a.opts.ctx, a), a.opts.stopTimeout)</span><br><span class="line">            <span class="keyword">defer</span> cancel()</span><br><span class="line">            <span class="keyword">return</span> srv.Stop(stopCtx)</span><br><span class="line">        &#125;)</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        eg.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">            wg.Done() <span class="comment">// here is to ensure server start has begun running before register, so defer is not needed</span></span><br><span class="line">            <span class="keyword">return</span> srv.Start(sctx)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="keyword">if</span> a.opts.registrar != <span class="literal">nil</span> &#123;</span><br><span class="line">        rctx, rcancel := context.WithTimeout(ctx, a.opts.registrarTimeout)</span><br><span class="line">        <span class="keyword">defer</span> rcancel()</span><br><span class="line">        <span class="keyword">if</span> err = a.opts.registrar.Register(rctx, instance); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, fn := <span class="keyword">range</span> a.opts.afterStart &#123;</span><br><span class="line">        <span class="keyword">if</span> err = fn(sctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 监听推出信号，监听的信号在NewApp的时候可以配置</span></span><br><span class="line">    signal.Notify(c, a.opts.sigs...)</span><br><span class="line">    eg.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            <span class="keyword">case</span> &lt;-c:</span><br><span class="line">            <span class="keyword">return</span> a.Stop()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 等着咯，服务已经run起来了</span></span><br><span class="line">    <span class="keyword">if</span> err = eg.Wait(); err != <span class="literal">nil</span> &amp;&amp; !errors.Is(err, context.Canceled) &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, fn := <span class="keyword">range</span> a.opts.afterStop &#123;</span><br><span class="line">        err = fn(sctx)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="i4ndz"></a></p>
<h1 id="中间件"><a class="markdownIt-Anchor" href="#中间件"></a> 中间件</h1>
<p>在http代码中使用时，这段是使用protoc-gen-go-http生成的代码，kratos在生成的代码中塞入了中间件的执行逻辑</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handler defines the handler invoked by Middleware.</span></span><br><span class="line"><span class="keyword">type</span> Handler <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Middleware is HTTP/gRPC transport middleware.</span></span><br><span class="line"><span class="keyword">type</span> Middleware <span class="function"><span class="keyword">func</span><span class="params">(Handler)</span></span> Handler</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过这个方法组装所有的中间件Handler，并返回一个新的中间件，所有中件间将按顺序链式执行</span></span><br><span class="line"><span class="comment">// Chain returns a Middleware that specifies the chained handler for endpoint.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Chain</span><span class="params">(m ...Middleware)</span></span> Middleware &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(next Handler)</span></span> Handler &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="built_in">len</span>(m) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">            next = m[i](next)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在grpc代码中使用时，kratos会在grpc的第一个拦截器中放入中间件的执行代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> _<span class="title">Helloworld_Helloworld0_HTTP_Handler</span><span class="params">(srv HelloworldHTTPServer)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(ctx http.Context)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx http.Context)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> in HelloworldRequest</span><br><span class="line">        <span class="keyword">if</span> err := ctx.BindQuery(&amp;in); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err := ctx.BindVars(&amp;in); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        http.SetOperation(ctx, <span class="string">&quot;/api.helloworld.service.v1.Helloworld/Helloworld&quot;</span>)</span><br><span class="line">        <span class="comment">// 生成整个执行的中间件链路Handler，最后的service方法将会放进中间件的最后一个执行</span></span><br><span class="line">        h := ctx.Middleware(<span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> srv.Helloworld(ctx, req.(*HelloworldRequest))</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 开始执行所有中件间</span></span><br><span class="line">        out, err := h(ctx, &amp;in)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        reply := out.(*HelloworldReply)</span><br><span class="line">        <span class="keyword">return</span> ctx.Result(<span class="number">200</span>, reply)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ctx.Middleware func</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *wrapper)</span></span> Middleware(h middleware.Handler) middleware.Handler &#123;</span><br><span class="line">    <span class="keyword">return</span> middleware.Chain(c.router.srv.ms...)(h)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// grpc/server.go NewServer</span></span><br><span class="line"><span class="comment">// ...省略</span></span><br><span class="line"><span class="comment">// kratos定义的第一个拦截器，中间件的执行在这里面</span></span><br><span class="line">unaryInts := []grpc.UnaryServerInterceptor&#123;</span><br><span class="line">    srv.unaryServerInterceptor(),</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 流式拦截器</span></span><br><span class="line">streamInts := []grpc.StreamServerInterceptor&#123;</span><br><span class="line">    srv.streamServerInterceptor(),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(srv.unaryInts) &gt; <span class="number">0</span> &#123;</span><br><span class="line">    unaryInts = <span class="built_in">append</span>(unaryInts, srv.unaryInts...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(srv.streamInts) &gt; <span class="number">0</span> &#123;</span><br><span class="line">    streamInts = <span class="built_in">append</span>(streamInts, srv.streamInts...)</span><br><span class="line">&#125;</span><br><span class="line">grpcOpts := []grpc.ServerOption&#123;</span><br><span class="line">    grpc.ChainUnaryInterceptor(unaryInts...),</span><br><span class="line">    grpc.ChainStreamInterceptor(streamInts...),</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unaryServerInterceptor is a gRPC unary server interceptor</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> unaryServerInterceptor() grpc.UnaryServerInterceptor &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">        <span class="comment">// ...省略代码</span></span><br><span class="line">        h := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> handler(ctx, req)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意这部分</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s.middleware) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            h = middleware.Chain(s.middleware...)(h)</span><br><span class="line">        &#125;</span><br><span class="line">        reply, err := h(ctx, req)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(replyHeader) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            _ = grpc.SetHeader(ctx, replyHeader)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reply, err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上都是服务端的实现，客户端也是类似的实现，通过抽象一个中间件来实现对grpc和http统一处理，只要一套中间件逻辑就能同时用在两个甚至多个不同协议中。<br />
<a name="WDZgj"></a></p>
<h1 id="组件"><a class="markdownIt-Anchor" href="#组件"></a> 组件</h1>
<p><a name="vIiCq"></a></p>
<h2 id="序列化"><a class="markdownIt-Anchor" href="#序列化"></a> 序列化</h2>
<p>这块没什么好说的，主要实现对不同的数据格式序列化和反序列化操作。<br />
<a name="iz0ul"></a></p>
<h3 id="json"><a class="markdownIt-Anchor" href="#json"></a> JSON</h3>
<p>特殊提一下json的默认序列化工具有一个小问题，序列化和反序列化时会识别是否为proto.Message，而使用proto自带的json序列化器，看代码可以发现，只断言了结构体对象，会导致如果为proto.Message数组时，无法正常使用proto的json序列化。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(codec)</span></span> Marshal(v <span class="keyword">interface</span>&#123;&#125;) ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> m := v.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> json.Marshaler:</span><br><span class="line">        <span class="keyword">return</span> m.MarshalJSON()</span><br><span class="line">        <span class="keyword">case</span> proto.Message:</span><br><span class="line">        <span class="keyword">return</span> MarshalOptions.Marshal(m)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> json.Marshal(m)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="xQ5ul"></a></p>
<h3 id="接口"><a class="markdownIt-Anchor" href="#接口"></a> 接口</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Codec <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Marshal returns the wire format of v.</span></span><br><span class="line">    Marshal(v <span class="keyword">interface</span>&#123;&#125;) ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line">    <span class="comment">// Unmarshal parses the wire format into v.</span></span><br><span class="line">    Unmarshal(data []<span class="type">byte</span>, v <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span></span><br><span class="line">    <span class="comment">// Name returns the name of the Codec implementation. The returned string</span></span><br><span class="line">    <span class="comment">// will be used as part of content type in transmission.  The result must be</span></span><br><span class="line">    <span class="comment">// static; the result cannot change between calls.</span></span><br><span class="line">    Name() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="gOIyj"></a></p>
<h3 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意全局序列化器，aw中遇到默认json解析器无法正常识别protobuf数组数据时，就是通过覆盖json序列化器来实现替换的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterCodec</span><span class="params">(codec Codec)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> codec == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;cannot register a nil Codec&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> codec.Name() == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;cannot register Codec with empty string result for Name()&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    contentSubtype := strings.ToLower(codec.Name())</span><br><span class="line">    registeredCodecs[contentSubtype] = codec</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一个序列化器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetCodec</span><span class="params">(contentSubtype <span class="type">string</span>)</span></span> Codec &#123;</span><br><span class="line">    <span class="keyword">return</span> registeredCodecs[contentSubtype]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="wkQV5"></a></p>
<h2 id="元数据"><a class="markdownIt-Anchor" href="#元数据"></a> 元数据</h2>
<p>客户端和服务端开启</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端</span></span><br><span class="line">http.Middleware(</span><br><span class="line">    metadata.Server(),</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line">grpc.WithMiddleware(</span><br><span class="line">    metadata.Client()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>先来看服务端的实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Server is middleware server-side metadata.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Server</span><span class="params">(opts ...Option)</span></span> middleware.Middleware &#123;</span><br><span class="line">    <span class="comment">// 这边定义了元数据传递的前缀，非这个前缀的数据不会被接收</span></span><br><span class="line">    options := &amp;options&#123;</span><br><span class="line">        prefix: []<span class="type">string</span>&#123;<span class="string">&quot;x-md-&quot;</span>&#125;, <span class="comment">// x-md-global-, x-md-local</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, o := <span class="keyword">range</span> opts &#123;</span><br><span class="line">        o(options)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(handler middleware.Handler)</span></span> middleware.Handler &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;)</span></span> (reply <span class="keyword">interface</span>&#123;&#125;, err <span class="type">error</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> tr, ok := transport.FromServerContext(ctx); ok &#123;</span><br><span class="line">                md := options.md.Clone()</span><br><span class="line">                header := tr.RequestHeader()</span><br><span class="line">                <span class="comment">// 从请求头中取出所有的符合前缀的数据到元数据中</span></span><br><span class="line">                <span class="keyword">for</span> _, k := <span class="keyword">range</span> header.Keys() &#123;</span><br><span class="line">                    <span class="keyword">if</span> options.hasPrefix(k) &#123;</span><br><span class="line">                        md.Set(k, header.Get(k))</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ctx = metadata.NewServerContext(ctx, md)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> handler(ctx, req)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看客户端的实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Client is middleware client-side metadata.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Client</span><span class="params">(opts ...Option)</span></span> middleware.Middleware &#123;</span><br><span class="line">    <span class="comment">// 同样定义的传递的前缀，这个前缀只会用在service上的元数据</span></span><br><span class="line">    options := &amp;options&#123;</span><br><span class="line">        prefix: []<span class="type">string</span>&#123;<span class="string">&quot;x-md-global-&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, o := <span class="keyword">range</span> opts &#123;</span><br><span class="line">        o(options)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(handler middleware.Handler)</span></span> middleware.Handler &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;)</span></span> (reply <span class="keyword">interface</span>&#123;&#125;, err <span class="type">error</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> tr, ok := transport.FromClientContext(ctx); ok &#123;</span><br><span class="line">                header := tr.RequestHeader()</span><br><span class="line">                <span class="comment">// x-md-local-</span></span><br><span class="line">                <span class="comment">// 本地的元数据，初始化中间件的时候传入，可以放入服务版本号，服务名，服务权重之类的信息，每次client请求都会带上</span></span><br><span class="line">                <span class="keyword">for</span> k, v := <span class="keyword">range</span> options.md &#123;</span><br><span class="line">                    header.Set(k, v)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// client的元数据，使用时需要业务主动NewClientContext创建一个包含client的元数据上下文</span></span><br><span class="line">                <span class="keyword">if</span> md, ok := metadata.FromClientContext(ctx); ok &#123;</span><br><span class="line">                    <span class="keyword">for</span> k, v := <span class="keyword">range</span> md &#123;</span><br><span class="line">                        header.Set(k, v)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 服务器中的元数据信息，可以看到只有被定义成x-md-global的元数据才会被全局传递</span></span><br><span class="line">                <span class="comment">// x-md-local只会被传递一次</span></span><br><span class="line">                <span class="keyword">if</span> md, ok := metadata.FromServerContext(ctx); ok &#123;</span><br><span class="line">                    <span class="keyword">for</span> k, v := <span class="keyword">range</span> md &#123;</span><br><span class="line">                        <span class="keyword">if</span> options.hasPrefix(k) &#123;</span><br><span class="line">                            header.Set(k, v)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> handler(ctx, req)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看下使用例子，全局传递用户信息</p>
<ol>
<li>首先最基本的需要在service和client中打开元数据的中间件，就不贴代码了</li>
<li>注入全局元数据</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 鉴权中间件中</span></span><br><span class="line"><span class="comment">// 注入元数据传递，这种方式有并发安全问题</span></span><br><span class="line"><span class="keyword">if</span> md, ok := metadata.FromServerContext(ctx); ok &#123;</span><br><span class="line">    <span class="comment">// 不可能err</span></span><br><span class="line">    userByte, _ := json.Marshal(user)</span><br><span class="line">    md.Set(userMetadataKey, <span class="type">string</span>(userByte))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者，这种是安全的</span></span><br><span class="line">ctx = metadata.AppendToClientContext(ctx, userMetadataKey, <span class="type">string</span>(userByte))</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>提取元数据</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserFromMetaDataContext</span><span class="params">(ctx context.Context)</span></span> *User &#123;</span><br><span class="line">    <span class="keyword">if</span> md, ok := metadata.FromServerContext(ctx); ok &#123;</span><br><span class="line">        userStr := md.Get(userMetadataKey)</span><br><span class="line">        <span class="keyword">if</span> userStr != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            user := User&#123;&#125;</span><br><span class="line">            err := json.Unmarshal([]<span class="type">byte</span>(userStr), &amp;user)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Errorf(<span class="string">&quot;user metadata Unmarshal fail err(%+v)&quot;</span>, err)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> &amp;user</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="GKKay"></a></p>
<h2 id="错误处理"><a class="markdownIt-Anchor" href="#错误处理"></a> 错误处理</h2>
<p><a name="yU9NM"></a></p>
<h1 id="奇奇怪怪的算法"><a class="markdownIt-Anchor" href="#奇奇怪怪的算法"></a> 奇奇怪怪的算法</h1>
<p><a name="OJxna"></a></p>
<h2 id="负载均衡算法-p2c"><a class="markdownIt-Anchor" href="#负载均衡算法-p2c"></a> 负载均衡算法 P2C</h2>
<p>论文：<a target="_blank" rel="noopener" href="http://www.eecs.harvard.edu/~michaelm/NEWWORK/postscripts/twosurvey.pdf">《The Power of Two Random Choices: A Survey of Techniques and Results》</a> 两次随机选择<br />实现：</p>
<ol>
<li>从可用节点列表中做 2 次随机选择，得到节点 nodeA、nodeB</li>
<li>比较 nodeA、nodeB 两个节点，选出负载最低（kratos中主要使用正在处理的请求数，延迟，健康度（请求成功率）来加权计算）的节点作为被选中的节点</li>
</ol>
<p>代码：没什么好说的，就随机选两个，比较权重</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Balancer)</span></span> Pick(ctx context.Context, nodes []selector.WeightedNode) (selector.WeightedNode, selector.DoneFunc, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nodes) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, selector.ErrNoAvailable</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nodes) == <span class="number">1</span> &#123;</span><br><span class="line">        done := nodes[<span class="number">0</span>].Pick()</span><br><span class="line">        <span class="keyword">return</span> nodes[<span class="number">0</span>], done, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> pc, upc selector.WeightedNode</span><br><span class="line">    nodeA, nodeB := s.prePick(nodes)</span><br><span class="line">    <span class="comment">// meta.Weight is the weight set by the service publisher in discovery</span></span><br><span class="line">    <span class="keyword">if</span> nodeB.Weight() &gt; nodeA.Weight() &#123;</span><br><span class="line">        pc, upc = nodeB, nodeA</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pc, upc = nodeA, nodeB</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里有一个强制选择的动作，如果有一个节点长期没有被选中过，那就让他强制选中一次，来更新节点的状态（健康度等等）</span></span><br><span class="line">    <span class="comment">// If the failed node has never been selected once during forceGap, it is forced to be selected once</span></span><br><span class="line">    <span class="comment">// Take advantage of forced opportunities to trigger updates of success rate and delay</span></span><br><span class="line">    <span class="keyword">if</span> upc.PickElapsed() &gt; forcePick &amp;&amp; atomic.CompareAndSwapInt64(&amp;s.picked, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        pc = upc</span><br><span class="line">        atomic.StoreInt64(&amp;s.picked, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    done := pc.Pick()</span><br><span class="line">    <span class="keyword">return</span> pc, done, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点：依赖随机所有节点都有机会被调度到，通过多个节点随机调度，可以避免羊群效应。<br />
<a name="g6dE9"></a></p>
<h2 id="负载均衡算法-wrr"><a class="markdownIt-Anchor" href="#负载均衡算法-wrr"></a> 负载均衡算法 WRR</h2>
<p>加权轮询<br />假设abc三个节点权重5，1，1<br />bad：{c, b, a, a, a, a, a} 分布不均匀，连续请求<br />good：{a, a, b, a, c, a, a} 分布均匀<br />比较简单直接上代码吧</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Balancer)</span></span> Pick(_ context.Context, nodes []selector.WeightedNode) (selector.WeightedNode, selector.DoneFunc, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nodes) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, selector.ErrNoAvailable</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> totalWeight <span class="type">float64</span></span><br><span class="line">    <span class="keyword">var</span> selected selector.WeightedNode</span><br><span class="line">    <span class="keyword">var</span> selectWeight <span class="type">float64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// nginx wrr load balancing algorithm: http://blog.csdn.net/zhangskd/article/details/50194069</span></span><br><span class="line">    p.mu.Lock()</span><br><span class="line">    <span class="keyword">for</span> _, node := <span class="keyword">range</span> nodes &#123;</span><br><span class="line">        <span class="comment">// 每次遍历所有的权重，计算权重总值total，每次遍历对于每个节点当前权重都会加上节点权重值</span></span><br><span class="line">        totalWeight += node.Weight()</span><br><span class="line">        cwt := p.currentWeight[node.Address()]</span><br><span class="line">        <span class="comment">// current += effectiveWeight</span></span><br><span class="line">        cwt += node.Weight()</span><br><span class="line">        p.currentWeight[node.Address()] = cwt</span><br><span class="line">        <span class="keyword">if</span> selected == <span class="literal">nil</span> || selectWeight &lt; cwt &#123;</span><br><span class="line">            selectWeight = cwt</span><br><span class="line">            selected = node</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 经过上面权重的选择，选出权重值最大的一个节点，选出的这个节点减去所有节点权重的总值total</span></span><br><span class="line">    <span class="comment">// 理论上经过一轮之后全部都会恢复到0值，并且分布均匀，选中一次之后权重就会下降，其他节点机会更高</span></span><br><span class="line">    p.currentWeight[selected.Address()] = selectWeight - totalWeight</span><br><span class="line">    p.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    d := selected.Pick()</span><br><span class="line">    <span class="keyword">return</span> selected, d, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="Hjl9M"></a></p>
<h1 id="细节补充"><a class="markdownIt-Anchor" href="#细节补充"></a> 细节补充</h1>
<p><a name="gKVaA"></a></p>
<h2 id="超时传递"><a class="markdownIt-Anchor" href="#超时传递"></a> 超时传递</h2>
<p>一开始还以为是kratos实现的，其实是grpc实现的<br />依赖grpc -&gt; http2 实现的超时传递<br />在http2中会放进去grpc-timeout的header，server会取出来处理<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/1487474/1691816746464-30d0cccd-f958-422a-bc88-8f48deeb32fa.png#averageHue=%232d2d2c&amp;clientId=u59b681d6-7a1d-4&amp;from=paste&amp;id=u2b677981&amp;originHeight=476&amp;originWidth=1682&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1e535603-38fd-4eec-86ab-0ce10cc8a8b&amp;title=" alt="" /><br />那如果是http client是不是就不会传递了呢？没错！，kratos没有处理<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/1487474/1691816746406-f828b076-b676-43e7-9863-3003cdf57939.png#averageHue=%232f2c2c&amp;clientId=u59b681d6-7a1d-4&amp;from=paste&amp;id=u81bb93e4&amp;originHeight=988&amp;originWidth=2076&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u41f2f3a6-467a-49af-a7f6-2400ebf1fdd&amp;title=" alt="" /><br />
<a name="ycDg4"></a></p>
<h2 id="负载均衡节点信息采集"><a class="markdownIt-Anchor" href="#负载均衡节点信息采集"></a> 负载均衡节点信息采集</h2>
<p><a name="yXczu"></a></p>
<h3 id="节点信息从哪来"><a class="markdownIt-Anchor" href="#节点信息从哪来"></a> 节点信息从哪来</h3>
<ol>
<li>服务注册组件会持续更新节点信息</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/1487474/1691816746453-64bea59d-718f-4cdc-a02a-8d8787e21640.png#averageHue=%232d2c2b&amp;clientId=u59b681d6-7a1d-4&amp;from=paste&amp;id=u528f54d4&amp;originHeight=1256&amp;originWidth=1738&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u105863a3-5316-43bd-bb95-33137fd9fae&amp;title=" alt="" /></p>
<ol start="2">
<li>grpc 创建负载均衡器时传入的节点信息（节点状态变更时会重新build，具体可以看Build的调用方）</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/1487474/1691816746401-94ec88fd-6a8b-4374-be20-892158806613.png#averageHue=%23302d2c&amp;clientId=u59b681d6-7a1d-4&amp;from=paste&amp;id=u0a28a0fe&amp;originHeight=778&amp;originWidth=1870&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua3543dff-5829-4890-8bf5-f4da423623f&amp;title=" alt="" /><br />
<a name="jm37N"></a></p>
<h3 id="负载均衡节点信息结构"><a class="markdownIt-Anchor" href="#负载均衡节点信息结构"></a> 负载均衡节点信息结构</h3>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/1487474/1691816747439-3c0997ff-15ff-4839-ba0c-24a123d291c1.png#averageHue=%233e4654&amp;clientId=u59b681d6-7a1d-4&amp;from=paste&amp;id=uf0314f0e&amp;originHeight=380&amp;originWidth=718&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc941a4fa-94c2-46f8-8517-593c7587986&amp;title=" alt="" /></p>
<ol>
<li><strong>direct</strong></li>
</ol>
<p>这个比较简单，固定权重，权重信息在一开始服务初始化的使用用元数据注入进去，需要开启服务注册的功能才会传递元数据<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/1487474/1691816747487-987b3a3e-bbc1-47e6-822e-2b07fa97ccdb.png#averageHue=%23302d2c&amp;clientId=u59b681d6-7a1d-4&amp;from=paste&amp;id=u428a2d05&amp;originHeight=556&amp;originWidth=1302&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u210bb887-23af-439f-ac86-bc74855ac8c&amp;title=" alt="" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/1487474/1691816747572-5d4d1f91-aaba-4f5e-b2eb-841d821197ff.png#averageHue=%232f2c2b&amp;clientId=u59b681d6-7a1d-4&amp;from=paste&amp;id=u2b4ead7e&amp;originHeight=716&amp;originWidth=1504&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2ad47b97-9abc-4b4a-9887-e59031eef04&amp;title=" alt="" /></p>
<ol start="2">
<li><strong>ewma</strong></li>
</ol>
<p>指数加权移动平均数，里面计算了几个值的ewma，主要包含健康度，正在处理的请求数，延迟（kratos1.0实现里面还带有cpu信息）</p>
<ul>
<li>先介绍两个常量值</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    <span class="comment">// The mean lifetime of `cost`, it reaches its half-life after Tau*ln(2).</span></span><br><span class="line">    <span class="comment">//  和半衰期相关的系数</span></span><br><span class="line">    tau = <span class="type">int64</span>(time.Millisecond * <span class="number">600</span>)</span><br><span class="line">    <span class="comment">// 惩罚值，刚加入的节点，给一个比较大的惩罚值，慢慢放流</span></span><br><span class="line">    penalty = <span class="type">uint64</span>(time.Second * <span class="number">10</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>初始化的默认值</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Build create a weighted node.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span></span> Build(n selector.Node) selector.WeightedNode &#123;</span><br><span class="line">    s := &amp;Node&#123;</span><br><span class="line">        Node:       n,</span><br><span class="line">        lag:        <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 默认100</span></span><br><span class="line">        success:    <span class="number">1000</span>,</span><br><span class="line">        <span class="comment">// 为什么是1呢！！！！保证分母不为0</span></span><br><span class="line">        inflight:   <span class="number">1</span>,</span><br><span class="line">        <span class="comment">// 请求列表，主要存放请求开始时间，用来请求延时</span></span><br><span class="line">        inflights:  list.New(),</span><br><span class="line">        errHandler: b.ErrHandler,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>节点信息计算</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span></span> Pick() selector.DoneFunc &#123;</span><br><span class="line">    now := time.Now().UnixNano()</span><br><span class="line">    <span class="comment">// 更新最后被选中的时间</span></span><br><span class="line">    atomic.StoreInt64(&amp;n.lastPick, now)</span><br><span class="line">    <span class="comment">// 正在处理的请求+1</span></span><br><span class="line">    atomic.AddInt64(&amp;n.inflight, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 累计请求数+1</span></span><br><span class="line">    atomic.AddInt64(&amp;n.reqs, <span class="number">1</span>)</span><br><span class="line">    n.lk.Lock()</span><br><span class="line">    e := n.inflights.PushBack(now)</span><br><span class="line">    n.lk.Unlock()</span><br><span class="line">    <span class="comment">// 执行结束之后会回调这个方法，完成一些信息更新</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, di selector.DoneInfo)</span></span> &#123;</span><br><span class="line">        n.lk.Lock()</span><br><span class="line">        n.inflights.Remove(e)</span><br><span class="line">        n.lk.Unlock()</span><br><span class="line">        atomic.AddInt64(&amp;n.inflight, <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        now := time.Now().UnixNano()</span><br><span class="line">        <span class="comment">// get moving average ratio w</span></span><br><span class="line">        stamp := atomic.SwapInt64(&amp;n.stamp, now)</span><br><span class="line">        td := now - stamp</span><br><span class="line">        <span class="keyword">if</span> td &lt; <span class="number">0</span> &#123;</span><br><span class="line">            td = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 衰减值，越近的数据影响越大，越早的数据权重越低</span></span><br><span class="line">        w := math.Exp(<span class="type">float64</span>(-td) / <span class="type">float64</span>(tau))</span><br><span class="line"></span><br><span class="line">        start := e.Value.(<span class="type">int64</span>)</span><br><span class="line">        lag := now - start</span><br><span class="line">        <span class="keyword">if</span> lag &lt; <span class="number">0</span> &#123;</span><br><span class="line">            lag = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        oldLag := atomic.LoadInt64(&amp;n.lag)</span><br><span class="line">        <span class="keyword">if</span> oldLag == <span class="number">0</span> &#123;</span><br><span class="line">            w = <span class="number">0.0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 耗时计算，使用ewma</span></span><br><span class="line">        lag = <span class="type">int64</span>(<span class="type">float64</span>(oldLag)*w + <span class="type">float64</span>(lag)*(<span class="number">1.0</span>-w))</span><br><span class="line">        atomic.StoreInt64(&amp;n.lag, lag)</span><br><span class="line"></span><br><span class="line">        success := <span class="type">uint64</span>(<span class="number">1000</span>) <span class="comment">// error value ,if error set 1</span></span><br><span class="line">        <span class="keyword">if</span> di.Err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> n.errHandler != <span class="literal">nil</span> &amp;&amp; n.errHandler(di.Err) &#123;</span><br><span class="line">                success = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> netErr net.Error</span><br><span class="line">            <span class="keyword">if</span> errors.Is(context.DeadlineExceeded, di.Err) || errors.Is(context.Canceled, di.Err) ||</span><br><span class="line">            errors.IsServiceUnavailable(di.Err) || errors.IsGatewayTimeout(di.Err) || errors.As(di.Err, &amp;netErr) &#123;</span><br><span class="line">                success = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        oldSuc := atomic.LoadUint64(&amp;n.success)</span><br><span class="line">        <span class="comment">// 成功率计算，也是用ewma</span></span><br><span class="line">        success = <span class="type">uint64</span>(<span class="type">float64</span>(oldSuc)*w + <span class="type">float64</span>(success)*(<span class="number">1.0</span>-w))</span><br><span class="line">        atomic.StoreUint64(&amp;n.success, success)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>负载计算</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span></span> load() (load <span class="type">uint64</span>) &#123;</span><br><span class="line">    now := time.Now().UnixNano()</span><br><span class="line">    avgLag := atomic.LoadInt64(&amp;n.lag)</span><br><span class="line">    lastPredictTs := atomic.LoadInt64(&amp;n.predictTs)</span><br><span class="line">    predictInterval := avgLag / <span class="number">5</span> <span class="comment">// 窗口</span></span><br><span class="line">    <span class="comment">// 限制预测区间为5ms-200ms</span></span><br><span class="line">    <span class="keyword">if</span> predictInterval &lt; <span class="type">int64</span>(time.Millisecond*<span class="number">5</span>) &#123;</span><br><span class="line">        predictInterval = <span class="type">int64</span>(time.Millisecond * <span class="number">5</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> predictInterval &gt; <span class="type">int64</span>(time.Millisecond*<span class="number">200</span>) &#123;</span><br><span class="line">        predictInterval = <span class="type">int64</span>(time.Millisecond * <span class="number">200</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前距离上一次预测超过预期间隔，且cas成功，则更新一次预测</span></span><br><span class="line">    <span class="keyword">if</span> now-lastPredictTs &gt; predictInterval &amp;&amp; atomic.CompareAndSwapInt64(&amp;n.predictTs, lastPredictTs, now) &#123;</span><br><span class="line">        <span class="keyword">var</span> (</span><br><span class="line">            total   <span class="type">int64</span></span><br><span class="line">            count   <span class="type">int</span></span><br><span class="line">            predict <span class="type">int64</span></span><br><span class="line">        )</span><br><span class="line">        n.lk.RLock()</span><br><span class="line">        first := n.inflights.Front()</span><br><span class="line">        <span class="keyword">for</span> first != <span class="literal">nil</span> &#123;</span><br><span class="line">            lag := now - first.Value.(<span class="type">int64</span>)</span><br><span class="line">            <span class="keyword">if</span> lag &gt; avgLag &#123;</span><br><span class="line">                count++</span><br><span class="line">                total += lag</span><br><span class="line">            &#125;</span><br><span class="line">            first = first.Next()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只有一半以上节点超过平均耗时才更新预测值？</span></span><br><span class="line">        <span class="keyword">if</span> count &gt; (n.inflights.Len()/<span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">            predict = total / <span class="type">int64</span>(count)</span><br><span class="line">        &#125;</span><br><span class="line">        n.lk.RUnlock()</span><br><span class="line">        atomic.StoreInt64(&amp;n.predict, predict)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> avgLag == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// penalty is the penalty value when there is no data when the node is just started.</span></span><br><span class="line">        <span class="comment">// The default value is 1e9 * 10</span></span><br><span class="line">        <span class="comment">// 节点刚启动，没有请求过，给个很大的惩罚值</span></span><br><span class="line">        load = penalty * <span class="type">uint64</span>(atomic.LoadInt64(&amp;n.inflight))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取预测值，如果预测值比平均值大，更换</span></span><br><span class="line">    predict := atomic.LoadInt64(&amp;n.predict)</span><br><span class="line">    <span class="keyword">if</span> predict &gt; avgLag &#123;</span><br><span class="line">        avgLag = predict</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 负载=平均延迟*正在处理的请求数</span></span><br><span class="line">    load = <span class="type">uint64</span>(avgLag) * <span class="type">uint64</span>(atomic.LoadInt64(&amp;n.inflight))</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>权重计算</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Weight is node effective weight.</span></span><br><span class="line"><span class="comment">// 对权重有积极影响的放分子，健康度（健康度越高越好），反之放分母即负载（负载包含正在处理的请求数，耗时）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span></span> Weight() (weight <span class="type">float64</span>) &#123;</span><br><span class="line">    weight = <span class="type">float64</span>(n.health()*<span class="type">uint64</span>(time.Second)) / <span class="type">float64</span>(n.load())</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>思考题</li>
</ul>
<p>predict是为了解决什么问题的？<br />
<a name="CJA2D"></a></p>
<h1 id="其他参考资料"><a class="markdownIt-Anchor" href="#其他参考资料"></a> 其他参考资料</h1>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/OAjcQdQxQzTRRv6q52JPNg">https://mp.weixin.qq.com/s/OAjcQdQxQzTRRv6q52JPNg</a><br /><a target="_blank" rel="noopener" href="https://github.com/go-kratos/kratos/blob/v1.0.x/pkg/net/rpc/warden/balancer/p2c/p2c.go">https://github.com/go-kratos/kratos/blob/v1.0.x/pkg/net/rpc/warden/balancer/p2c/p2c.go</a><br /><a target="_blank" rel="noopener" href="https://pandaychen.github.io/2020/07/25/KRATOS-WARDEN-BALANCER-P2C-ANALYSIS/">https://pandaychen.github.io/2020/07/25/KRATOS-WARDEN-BALANCER-P2C-ANALYSIS/</a><br /><a target="_blank" rel="noopener" href="https://blog.naaln.com/2019/08/newton-law-cooling/">https://blog.naaln.com/2019/08/newton-law-cooling/</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">fish</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://fishx233.github.io/2023/02/22/Kratos源码解读/">https://fishx233.github.io/2023/02/22/Kratos源码解读/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2023/03/09/visual-chatgpt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><i class="fa fa-chevron-left">  </i><span>visual-chatgpt源码分析</span></a></div><div class="next-post pull-right"><a href="/2022/09/09/MySQL%20SQL%20Modes%E4%B8%8D%E5%90%8C%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98/"><span>MySQL SQL Modes不同引发的血案</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(/media/101485281_p0_master1200.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2023 By fish</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>