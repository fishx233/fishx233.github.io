<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Go Map实现"><meta name="keywords" content=""><meta name="author" content="fish"><meta name="copyright" content="fish"><title>Go Map实现 | fish</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.3.0'
} </script><meta name="generator" content="Hexo 6.3.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text"> 数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#hmap"><span class="toc-number">1.1.</span> <span class="toc-text"> hmap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bmap"><span class="toc-number">1.2.</span> <span class="toc-text"> bmap</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text"> 核心方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96map"><span class="toc-number">2.1.</span> <span class="toc-text"> 初始化map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-number">2.2.</span> <span class="toc-text"> 查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%9F%A5%E6%89%BE%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.1.</span> <span class="toc-text"> 其他查找方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC"><span class="toc-number">2.3.</span> <span class="toc-text"> 赋值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9"><span class="toc-number">2.4.</span> <span class="toc-text"> 扩容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%92%8C%E6%B8%85%E7%A9%BA"><span class="toc-number">2.5.</span> <span class="toc-text"> 删除和清空</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4"><span class="toc-number">2.5.1.</span> <span class="toc-text"> 删除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%94%AF%E6%8C%81%E4%BB%BB%E6%84%8F%E7%B1%BB%E5%9E%8Bkv"><span class="toc-number">3.</span> <span class="toc-text"> 实现支持任意类型kv</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6%E9%87%8D%E5%86%99"><span class="toc-number">4.</span> <span class="toc-text"> 编译时重写</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E8%B0%83%E7%94%A8"><span class="toc-number">5.</span> <span class="toc-text"> 运行时调用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0"><span class="toc-number">6.</span> <span class="toc-text"> 辅助函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text"> 总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/media/44b726fcde934f76ac03a9a019fbb060.jpeg"></div><div class="author-info__name text-center">fish</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">9</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">7</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/media/101485281_p0_master1200.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">fish</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Go Map实现</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-04-10</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Go/">Go</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Go/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><meta name="referrer" content="no-referrer" />
本文相关代码均基于**Go1.20**
<h1 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h1>
<h2 id="hmap"><a class="markdownIt-Anchor" href="#hmap"></a> hmap</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/map.go:hmap</span></span><br><span class="line"><span class="comment">// map的结构体，hmap即hashmap：</span></span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    count      <span class="type">int</span> <span class="comment">// item数，len(map)时返回</span></span><br><span class="line">	flags      <span class="type">uint8</span> <span class="comment">// 标记，一共有四个, 可以看常量定义，主要是 goroutine 写入和扩容机制的相关状态控制</span></span><br><span class="line">	B          <span class="type">uint8</span>  <span class="comment">// 2^B个桶</span></span><br><span class="line">	noverflow  <span class="type">uint16</span> <span class="comment">// 溢出桶的个数 近似值，非精确值</span></span><br><span class="line">	hash0      <span class="type">uint32</span> <span class="comment">// hash种子</span></span><br><span class="line">	buckets    unsafe.Pointer <span class="comment">// 指向桶结构的指针，大小为2^B，结构体为bmap，即指向[]bmap</span></span><br><span class="line">	oldbuckets unsafe.Pointer <span class="comment">// 结构同上，扩容时使用，旧的桶，等量扩容时和buckets长度相同，非等量扩容时为buckets的1/2，正常情况下为空</span></span><br><span class="line">	nevacuate  <span class="type">uintptr</span>  <span class="comment">// 扩容进度</span></span><br><span class="line">	extra      *mapextra</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/runtime/map.go:mapextra</span></span><br><span class="line"><span class="keyword">type</span> mapextra <span class="keyword">struct</span> &#123;</span><br><span class="line">	overflow    *[]*bmap</span><br><span class="line">	oldoverflow *[]*bmap</span><br><span class="line"></span><br><span class="line">	nextOverflow *bmap</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>mapextra</strong></p>
<p>当key和elem都是非指针类型的时候，会标记存储桶为不包含指针类型，从而避免gc扫描map，此时bmap中的overflow会保存在mapextra中的overflow，oldoverflow同理为扩容时使用旧桶的溢出桶。nextOverflow则为空闲待分配的溢出桶。</p>
<p>如果 keys 和 values 都不包含指针并且允许内联的情况下。会将 bucket 标识为不包含指针，使用extra来存储溢出桶就可以避免 GC 扫描整个map。</p>
<p><strong>B</strong></p>
<p>b决定了map可以承载的元素大小，一般来说map的最大容量为 6.5（负载因子） * 2^B，超过这个数量这会开始扩容操作，那么为什么map的bucket的大小被限制为了2的次方呢，这是一个比较常用的求余计算加速的方法，当桶的数量为2的次方时，<code>hash%bucket</code>相当于<code>hash &amp; ((1 &lt;&lt; B)-1)</code>即hash的低bucket位结果。</p>
<p>例如hash=1001010，B=3，bucket=8，则求余结果就为1001010的低3位010</p>
<h2 id="bmap"><a class="markdownIt-Anchor" href="#bmap"></a> bmap</h2>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/map.go:bmap</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	tophash [bucketCnt]<span class="type">uint8</span> <span class="comment">// 存储元素高八位值，用于快速试错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bmap即hash中bucket的结构，但上面的结构非最终结构，编译时会动态创建结构，参考如下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/cmd/compile/internal/reflectdata/reflect.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MapBucketType</span><span class="params">(t *types.Type)</span></span> *types.Type &#123;</span><br><span class="line">	<span class="keyword">if</span> t.MapType().Bucket != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> t.MapType().Bucket</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	keytype := t.Key()</span><br><span class="line">	elemtype := t.Elem()</span><br><span class="line">	types.CalcSize(keytype)</span><br><span class="line">	types.CalcSize(elemtype)</span><br><span class="line">	<span class="keyword">if</span> keytype.Size() &gt; MAXKEYSIZE &#123;</span><br><span class="line">		keytype = types.NewPtr(keytype)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> elemtype.Size() &gt; MAXELEMSIZE &#123;</span><br><span class="line">		elemtype = types.NewPtr(elemtype)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 这里应该可以改成4了，在旧的版本中还可能有一个&quot;pad&quot;字段，后面已经去掉了，参考https://github.com/golang/go/commit/ba97d0d84d4272c4b8497fa6af2eab1580b62d44</span></span><br><span class="line">	field := <span class="built_in">make</span>([]*types.Field, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">	<span class="comment">// topbits</span></span><br><span class="line">	arr := types.NewArray(types.Types[types.TUINT8], BUCKETSIZE)</span><br><span class="line">	field = <span class="built_in">append</span>(field, makefield(<span class="string">&quot;topbits&quot;</span>, arr))</span><br><span class="line"></span><br><span class="line">	arr = types.NewArray(keytype, BUCKETSIZE)</span><br><span class="line">	arr.SetNoalg(<span class="literal">true</span>)</span><br><span class="line">    <span class="comment">// keys</span></span><br><span class="line">	keys := makefield(<span class="string">&quot;keys&quot;</span>, arr)</span><br><span class="line">	field = <span class="built_in">append</span>(field, keys)</span><br><span class="line">	<span class="comment">// elems</span></span><br><span class="line">	arr = types.NewArray(elemtype, BUCKETSIZE)</span><br><span class="line">	arr.SetNoalg(<span class="literal">true</span>)</span><br><span class="line">	elems := makefield(<span class="string">&quot;elems&quot;</span>, arr)</span><br><span class="line">	field = <span class="built_in">append</span>(field, elems)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里</span></span><br><span class="line">    <span class="comment">// 如果keys和elems没有指针, 则map实现可以在这保留一个 overflow指针列表, 以便可以将 buckets 标记为没有指针.</span></span><br><span class="line">    <span class="comment">// 在这种情况下, 通过将 overflow 字段的类型更改为 uintptr, 使存储桶不包含任何指针.</span></span><br><span class="line">    <span class="comment">// 不包含指针的桶可以加快GC过程，此时溢出桶会放在extra中</span></span><br><span class="line">	otyp := types.Types[types.TUNSAFEPTR]</span><br><span class="line">	<span class="keyword">if</span> !elemtype.HasPointers() &amp;&amp; !keytype.HasPointers() &#123;</span><br><span class="line">		otyp = types.Types[types.TUINTPTR]</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// overflow</span></span><br><span class="line">	overflow := makefield(<span class="string">&quot;overflow&quot;</span>, otyp)</span><br><span class="line">	field = <span class="built_in">append</span>(field, overflow)</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从上面代码可以看出，编译时bmap动态创建实际为如下结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	topbits  [<span class="number">8</span>]<span class="type">uint8</span></span><br><span class="line">    keys     [<span class="number">8</span>]keytype</span><br><span class="line">    elems    [<span class="number">8</span>]elemtype</span><br><span class="line">    overflow <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这个结构可以看到，每个桶中最多存储8个元素，并且超出的元素会被存储到溢出桶overflow中，每个溢出桶的结构和bmap相同，overflow指向下一个bmap链接起来。</p>
<p><strong>hash冲突解决</strong></p>
<p>Go的map实现解决hash冲突的方式使用的是链地址法，那么Go的这种结构对于普通的链表有什么优势呢？链表的缺点大家应该比较熟悉，因为内存不连续，所以相对的<strong>随机访问</strong>较慢，容易产生<strong>碎片</strong>且对<strong>cpu缓存</strong>不友好，那么这种数据结构就可以减弱链表的缺点，因为链表的每个对象都存储了8个元素，可以加快访问，在空间和时间上做了一个平衡。</p>
<p><strong>kv结构</strong></p>
<p>为什么bmap不使用key/value/key/value而是选择key/key/…/value/value/value的内存结构，主要是这种结构可以消除内存对齐的padding，比如map[int64]int8时，如果使用key/value格式，会有很多padding。</p>
<p><img src="%5Cmedia%5C1.png" alt="" /></p>
<p><strong>整体结构</strong></p>
<p><img src="%5Cmedia%5Cimage0.jpeg" alt="" /></p>
<h1 id="核心方法"><a class="markdownIt-Anchor" href="#核心方法"></a> 核心方法</h1>
<h2 id="初始化map"><a class="markdownIt-Anchor" href="#初始化map"></a> 初始化map</h2>
<p>一般来说我们会使用<code>make(map[k]v, hint)</code>或<code>make(map[k]v)</code>来初始化一个map，接下来我们看一下相关源码。</p>
<p>当hint &lt; 8时调用的是<code>makemap_small</code>，makemap_small比较简单，并没有做bucket的初始化，而是延后惰性初始化，此时B的值还是0，会在后续mapassign时进行分配。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap_small</span><span class="params">()</span></span> *hmap &#123;</span><br><span class="line">	h := <span class="built_in">new</span>(hmap)</span><br><span class="line">	h.hash0 = fastrand()</span><br><span class="line">	<span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当hint &gt; 8时调用的则是 <code>makemap</code>，此时会根据hint的数据计算B，并初始化Bucket。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/map.go:makemap</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *maptype, hint <span class="type">int</span>, h *hmap)</span></span> *hmap &#123;</span><br><span class="line">	mem, overflow := math.MulUintptr(<span class="type">uintptr</span>(hint), t.bucket.size)</span><br><span class="line">	<span class="keyword">if</span> overflow || mem &gt; maxAlloc &#123;</span><br><span class="line">		hint = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化map</span></span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">		h = <span class="built_in">new</span>(hmap)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 分配hash种子</span></span><br><span class="line">	h.hash0 = fastrand()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算B的值</span></span><br><span class="line">	B := <span class="type">uint8</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> overLoadFactor(hint, B) &#123;</span><br><span class="line">		B++</span><br><span class="line">	&#125;</span><br><span class="line">	h.B = B</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> h.B != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> nextOverflow *bmap</span><br><span class="line">        <span class="comment">// 初始化bucket和预分配溢出桶</span></span><br><span class="line">		h.buckets, nextOverflow = makeBucketArray(t, h.B, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">			h.extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line">			h.extra.nextOverflow = nextOverflow</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们接着往下看下makeBucketArray，该方法实现了初始化bucket和预分配overflow相关代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/map.go:makeBucketArray</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeBucketArray</span><span class="params">(t *maptype, b <span class="type">uint8</span>, dirtyalloc unsafe.Pointer)</span></span> (buckets unsafe.Pointer, nextOverflow *bmap) &#123;</span><br><span class="line">	base := bucketShift(b) <span class="comment">// 2^B</span></span><br><span class="line">	nbuckets := base</span><br><span class="line">	<span class="comment">// 当b&lt;4时使用溢出桶的概率不大，此时不会考虑预分配溢出桶</span></span><br><span class="line">	<span class="keyword">if</span> b &gt;= <span class="number">4</span> &#123;</span><br><span class="line">		<span class="comment">// 计算预分配的溢出桶数量</span></span><br><span class="line">		nbuckets += bucketShift(b - <span class="number">4</span>)</span><br><span class="line">		sz := t.bucket.size * nbuckets</span><br><span class="line">		up := roundupsize(sz)</span><br><span class="line">		<span class="keyword">if</span> up != sz &#123;</span><br><span class="line">			nbuckets = up / t.bucket.size</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// dirtyalloc是nil或之前由makeBucketArray分配的具有相同t和b参数的存储桶数组。如果dirtyalloc 为 nil，则将分配一个新的Bucket数组，否则dirtyalloc将被清除并复用。</span></span><br><span class="line">	<span class="keyword">if</span> dirtyalloc == <span class="literal">nil</span> &#123;</span><br><span class="line">		buckets = newarray(t.bucket, <span class="type">int</span>(nbuckets))</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		buckets = dirtyalloc</span><br><span class="line">		size := t.bucket.size * nbuckets</span><br><span class="line">		<span class="keyword">if</span> t.bucket.ptrdata != <span class="number">0</span> &#123;</span><br><span class="line">			memclrHasPointers(buckets, size)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			memclrNoHeapPointers(buckets, size)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> base != nbuckets &#123;</span><br><span class="line">		<span class="comment">// 预分配的溢出存储桶的溢出指针为nil，则通过碰撞指针可以获得更多可用指针。并用一个安全的非nil 指针来表示最后一个溢出存储桶;</span></span><br><span class="line">		nextOverflow = (*bmap)(add(buckets, base*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">		last := (*bmap)(add(buckets, (nbuckets<span class="number">-1</span>)*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">		last.setoverflow(t, (*bmap)(buckets)) <span class="comment">// last指针的overflow指向的是buckets</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> buckets, nextOverflow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化map的内容大概就这些，我们来总结一下一些需要<strong>注意的点</strong>：</p>
<ul>
<li>makemap返回的数据为指针，所以入参为map时，对map修改会反应到原来的map中。</li>
<li>初始化时，会通过 <code>makeBucketArray</code> 对 buckets 进行分配（hint&gt;8）。因此在初始化时指定一个适当大小的容量。能够提升性能，减少后续的频繁分配。</li>
</ul>
<h2 id="查找"><a class="markdownIt-Anchor" href="#查找"></a> 查找</h2>
<p>查找可以说是map的核心方法了，map的大部分操作都是在查找的基础上进行的，例如赋值，删除等等。</p>
<p>函数原型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer <span class="comment">// 对应 v := h[k]</span></span><br><span class="line">mapaccess2(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, <span class="type">bool</span>) <span class="comment">// 对应 v, ok := h[k]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>mapaccess1：返回 <code>h[key]</code> 的指针地址，如果键不在 <code>map</code> 中，将返回对应类型的零值</li>
<li>mapaccess2：返回 <code>h[key]</code> 的指针地址，如果键不在 <code>map</code> 中，将返回零值和布尔值用于判断</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/map.go:mapaccess1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccess1</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line">	<span class="comment">// 跳过各种检查</span></span><br><span class="line">    <span class="comment">// 如果map为空或者元素个数为0, 返回零值</span></span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> t.hashMightPanic() &#123;</span><br><span class="line">			t.hasher(key, <span class="number">0</span>) <span class="comment">// see issue 23734</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 并发操作检测</span></span><br><span class="line">	<span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">		fatal(<span class="string">&quot;concurrent map read and map write&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	hash := t.hasher(key, <span class="type">uintptr</span>(h.hash0)) <span class="comment">// 计算hash值</span></span><br><span class="line">	m := bucketMask(h.B) <span class="comment">// 求余掩码</span></span><br><span class="line">	b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="type">uintptr</span>(t.bucketsize))) <span class="comment">// 计算桶的位置</span></span><br><span class="line">    <span class="comment">// 如果在扩容中</span></span><br><span class="line">	<span class="keyword">if</span> c := h.oldbuckets; c != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">			m &gt;&gt;= <span class="number">1</span> <span class="comment">// 如果是等量扩容，则m需要右移一位，例如B=4时为1111，则B=3为0111</span></span><br><span class="line">		&#125;</span><br><span class="line">		oldb := (*bmap)(add(c, (hash&amp;m)*<span class="type">uintptr</span>(t.bucketsize))) <span class="comment">// 计算出k在旧桶的位置</span></span><br><span class="line">		<span class="keyword">if</span> !evacuated(oldb) &#123; <span class="comment">// 计算这个旧桶是否已经被扩容搬移完成，如果没有完成需要把b定位到旧桶去</span></span><br><span class="line">			b = oldb</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	top := tophash(hash) <span class="comment">// hash值的高八位，用于topbits快速比较</span></span><br><span class="line">bucketloop:</span><br><span class="line">	<span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123; <span class="comment">// 遍历所有溢出桶查找数据</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">				<span class="keyword">if</span> b.tophash[i] == emptyRest &#123; <span class="comment">// emptyRest表示该cell为空且后续cell未使用，可以跳到下一个桶了</span></span><br><span class="line">					<span class="keyword">break</span> bucketloop</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">			<span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">				k = *((*unsafe.Pointer)(k))</span><br><span class="line">			&#125;</span><br><span class="line">           	<span class="comment">// 查找到key后计算value位置，返回value</span></span><br><span class="line">			<span class="keyword">if</span> t.key.equal(key, k) &#123;</span><br><span class="line">				e := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+i*<span class="type">uintptr</span>(t.elemsize))</span><br><span class="line">				<span class="keyword">if</span> t.indirectelem() &#123;</span><br><span class="line">					e = *((*unsafe.Pointer)(e))</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> e</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他查找方法"><a class="markdownIt-Anchor" href="#其他查找方法"></a> 其他查找方法</h3>
<p>（代码在src/runtime/hashmap_fast.go）</p>
<table>
<thead>
<tr>
<th>key 类型</th>
<th>查找</th>
</tr>
</thead>
<tbody>
<tr>
<td>uint32</td>
<td>mapaccess1_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer</td>
</tr>
<tr>
<td>uint32</td>
<td>mapaccess2_fast32(t *maptype, h *hmap, key uint32) (unsafe.Pointer, bool)</td>
</tr>
<tr>
<td>uint64</td>
<td>mapaccess1_fast64(t *maptype, h *hmap, key uint64) unsafe.Pointer</td>
</tr>
<tr>
<td>uint64</td>
<td>mapaccess2_fast64(t *maptype, h *hmap, key uint64) (unsafe.Pointer, bool)</td>
</tr>
<tr>
<td>string</td>
<td>mapaccess1_faststr(t *maptype, h *hmap, ky string) unsafe.Pointer</td>
</tr>
<tr>
<td>string</td>
<td>mapaccess2_faststr(t *maptype, h *hmap, ky string) (unsafe.Pointer, bool)</td>
</tr>
</tbody>
</table>
<p>这些函数的参数类型直接是具体的 uint32、unt64、string，在函数内部由于提前知道 key 的类型，所以内存布局是很清楚的，因此能节省很多操作，提高效率，类似于范型实现的单态化。</p>
<h2 id="赋值"><a class="markdownIt-Anchor" href="#赋值"></a> 赋值</h2>
<p>赋值方法也跟查询方法很相似，查询后如果没有找到对应的值将分配一个插槽给新值，同时多了一些扩容操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/map.go:mapassign</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapassign</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line">	<span class="comment">// 略过一堆检查和mapaccess相似代码</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> h.buckets == <span class="literal">nil</span> &#123;</span><br><span class="line">		h.buckets = newobject(t.bucket) <span class="comment">// newarray(t.bucket, 1)</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// 如果需要扩容，会先执行扩容操作，然后跳到again中，重新执行操作</span></span><br><span class="line">again:</span><br><span class="line">	bucket := hash &amp; bucketMask(h.B)</span><br><span class="line">	<span class="keyword">if</span> h.growing() &#123; <span class="comment">// 由于Go map为渐进式扩容，如果桶未完成扩容会优先进行该桶的搬移动作，并选择另一个桶进行搬移，即每次mapassign会搬移两个桶</span></span><br><span class="line">		growWork(t, h, bucket) </span><br><span class="line">	&#125;</span><br><span class="line">	b := (*bmap)(add(h.buckets, bucket*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">	top := tophash(hash)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> inserti *<span class="type">uint8</span></span><br><span class="line">	<span class="keyword">var</span> insertk unsafe.Pointer</span><br><span class="line">	<span class="keyword">var</span> elem unsafe.Pointer</span><br><span class="line"><span class="comment">// 以下操作都类似于mapaccess</span></span><br><span class="line">bucketloop:</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line">                <span class="comment">// 找到了一个空的插槽，先标记这个位置，如果该key未找到，则在这个空插槽插入这个kv即可</span></span><br><span class="line">				<span class="keyword">if</span> isEmpty(b.tophash[i]) &amp;&amp; inserti == <span class="literal">nil</span> &#123;</span><br><span class="line">					inserti = &amp;b.tophash[i]</span><br><span class="line">					insertk = add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">					elem = add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+i*<span class="type">uintptr</span>(t.elemsize))</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">					<span class="keyword">break</span> bucketloop</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">			<span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">				k = *((*unsafe.Pointer)(k))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> !t.key.equal(key, k) &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">// 到这里说明已经找到对应已存在的key了，直接goto到done去</span></span><br><span class="line">			<span class="keyword">if</span> t.needkeyupdate() &#123; <span class="comment">// 参考src/cmd/compile/internal/reflectdata/reflect.go 判断key是否为需要更新，跟float和complex相关</span></span><br><span class="line">				typedmemmove(t.key, k, key) <span class="comment">// 覆盖key</span></span><br><span class="line">			&#125;</span><br><span class="line">			elem = add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+i*<span class="type">uintptr</span>(t.elemsize))</span><br><span class="line">			<span class="keyword">goto</span> done</span><br><span class="line">		&#125;</span><br><span class="line">		ovf := b.overflow(t)</span><br><span class="line">		<span class="keyword">if</span> ovf == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		b = ovf</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 到这里说明没有已存在的key，需要分配溢出桶或空插槽</span></span><br><span class="line">    <span class="comment">// 判断是否需要扩容，如果不在扩容状态中，且达到扩容条件则进行扩容</span></span><br><span class="line">	<span class="keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;</span><br><span class="line">		hashGrow(t, h)</span><br><span class="line">		<span class="keyword">goto</span> again <span class="comment">// 扩容完需要重新走插入流程</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> inserti == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 为空表示没有合适的空插槽，需要分配新的溢出桶</span></span><br><span class="line">		newb := h.newoverflow(t, b)</span><br><span class="line">		inserti = &amp;newb.tophash[<span class="number">0</span>]</span><br><span class="line">		insertk = add(unsafe.Pointer(newb), dataOffset)</span><br><span class="line">		elem = add(insertk, bucketCnt*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果是直接存储key/value</span></span><br><span class="line">	<span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">		kmem := newobject(t.key)</span><br><span class="line">		*(*unsafe.Pointer)(insertk) = kmem</span><br><span class="line">		insertk = kmem</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> t.indirectelem() &#123;</span><br><span class="line">		vmem := newobject(t.elem)</span><br><span class="line">		*(*unsafe.Pointer)(elem) = vmem</span><br><span class="line">	&#125;</span><br><span class="line">	typedmemmove(t.key, insertk, key)</span><br><span class="line">	*inserti = top</span><br><span class="line">	h.count++</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    ... </span><br><span class="line">	<span class="keyword">if</span> t.indirectelem() &#123;</span><br><span class="line">		elem = *((*unsafe.Pointer)(elem))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> elem</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，<code>mapassign</code> 中, 没有直接将 value 写入内存, 而是将 value 在内存当中的对应地址返回, 后续对内存地址写入进行操作.</p>
<h2 id="扩容"><a class="markdownIt-Anchor" href="#扩容"></a> 扩容</h2>
<p>随着map中的key越来越多，key发生碰撞的概率也越来越大。溢出桶的数量变多，会导致操作时间变长，甚至退化为O(n)，所以当元素过多或溢出桶数量过多时，会触发map的扩容操作，来重新平衡数据分布。</p>
<p>扩容条件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;</span><br><span class="line">	hashGrow(t, h)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 超过最大负载，触发两倍扩容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">overLoadFactor</span><span class="params">(count <span class="type">int</span>, B <span class="type">uint8</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// map元素 &gt; 8 且 map元素 &gt; 6.5*2^B // 这里6.5不是直接算，而是使用loadFactorNum/loadFactorDen来计算6.5，这样可以避免浮点数计算，只使用整数计算</span></span><br><span class="line">	<span class="keyword">return</span> count &gt; bucketCnt &amp;&amp; <span class="type">uintptr</span>(count) &gt; loadFactorNum*(bucketShift(B)/loadFactorDen)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 溢出桶数量过多，触发等量扩容</span></span><br><span class="line"><span class="comment">// 当B小于15，如果overflow的bucket数量超过2^B；当B&gt;=15，如果overflow的数量超过2^15。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tooManyOverflowBuckets</span><span class="params">(noverflow <span class="type">uint16</span>, B <span class="type">uint8</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> B &gt; <span class="number">15</span> &#123;</span><br><span class="line">		B = <span class="number">15</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> noverflow &gt;= <span class="type">uint16</span>(<span class="number">1</span>)&lt;&lt;(B&amp;<span class="number">15</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>loadFactor负载因子被固定为6.5，因为6.5是一个测试效果较好的负载因子。</p>
<table>
<thead>
<tr>
<th>loadFactor</th>
<th>%overflow</th>
<th>bytes/entry</th>
<th>hitprobe</th>
<th>missprobe</th>
</tr>
</thead>
<tbody>
<tr>
<td>4.00</td>
<td>2.13</td>
<td>20.77</td>
<td>3.00</td>
<td>4.00</td>
</tr>
<tr>
<td>4.50</td>
<td>4.05</td>
<td>17.30</td>
<td>3.25</td>
<td>4.50</td>
</tr>
<tr>
<td>5.00</td>
<td>6.85</td>
<td>14.77</td>
<td>3.50</td>
<td>5.00</td>
</tr>
<tr>
<td>5.50</td>
<td>10.55</td>
<td>12.94</td>
<td>3.75</td>
<td>5.50</td>
</tr>
<tr>
<td>6.00</td>
<td>15.27</td>
<td>11.67</td>
<td>4.00</td>
<td>6.00</td>
</tr>
<tr>
<td>6.50</td>
<td>20.90</td>
<td>10.79</td>
<td>4.25</td>
<td>6.50</td>
</tr>
<tr>
<td>7.00</td>
<td>27.14</td>
<td>10.15</td>
<td>4.50</td>
<td>7.00</td>
</tr>
</tbody>
</table>
<p>扩容：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/map.go:hashGrow</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hashGrow</span><span class="params">(t *maptype, h *hmap)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 两倍扩容</span></span><br><span class="line">	bigger := <span class="type">uint8</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 非两倍扩容则为等量扩容</span></span><br><span class="line">	<span class="keyword">if</span> !overLoadFactor(h.count+<span class="number">1</span>, h.B) &#123;</span><br><span class="line">		bigger = <span class="number">0</span></span><br><span class="line">		h.flags |= sameSizeGrow</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 一些初始化新桶和赋值操作</span></span><br><span class="line">  	h.B += bigger <span class="comment">// B+1, 即桶数量扩一倍  </span></span><br><span class="line">	...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 溢出桶设置</span></span><br><span class="line">	<span class="keyword">if</span> h.extra != <span class="literal">nil</span> &amp;&amp; h.extra.overflow != <span class="literal">nil</span> &#123;</span><br><span class="line">		...</span><br><span class="line">		h.extra.oldoverflow = h.extra.overflow</span><br><span class="line">		h.extra.overflow = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> h.extra == <span class="literal">nil</span> &#123;</span><br><span class="line">			h.extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line">		&#125;</span><br><span class="line">		h.extra.nextOverflow = nextOverflow</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当触发扩容时，并不会立即触发搬移桶操作，而是会延迟到<code>growWork</code> 函数中执行，<code>growWork</code>会在赋值和删除时触发。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growWork</span><span class="params">(t *maptype, h *hmap, bucket <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 搬移指定的桶</span></span><br><span class="line">	evacuate(t, h, bucket&amp;h.oldbucketmask())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 并且多搬移一个桶</span></span><br><span class="line">	<span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">		evacuate(t, h, h.nevacuate)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 搬移信息</span></span><br><span class="line"><span class="keyword">type</span> evacDst <span class="keyword">struct</span> &#123;</span><br><span class="line">	b *bmap          <span class="comment">// 目标存储桶</span></span><br><span class="line">	i <span class="type">int</span>            <span class="comment">// kv index into b</span></span><br><span class="line">	k unsafe.Pointer <span class="comment">// 当前key指针</span></span><br><span class="line">	e unsafe.Pointer <span class="comment">// 当前elem指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行搬移桶操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evacuate</span><span class="params">(t *maptype, h *hmap, oldbucket <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">	b := (*bmap)(add(h.oldbuckets, oldbucket*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">	newbit := h.noldbuckets() <span class="comment">// 原先的旧桶数量</span></span><br><span class="line">	<span class="keyword">if</span> !evacuated(b) &#123; <span class="comment">// 判断是否已经被搬离</span></span><br><span class="line">		<span class="comment">// 包含了高低区间的搬迁目的地内存信息</span></span><br><span class="line">		<span class="keyword">var</span> xy [<span class="number">2</span>]evacDst</span><br><span class="line">		x := &amp;xy[<span class="number">0</span>]</span><br><span class="line">		x.b = (*bmap)(add(h.buckets, oldbucket*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">		x.k = add(unsafe.Pointer(x.b), dataOffset)</span><br><span class="line">		x.e = add(x.k, bucketCnt*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">		<span class="comment">// 只有非等量扩容才计算y，双倍扩容时，旧桶的元素可能落在新桶的x或y中</span></span><br><span class="line">		<span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">			y := &amp;xy[<span class="number">1</span>]</span><br><span class="line">			y.b = (*bmap)(add(h.buckets, (oldbucket+newbit)*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">			y.k = add(unsafe.Pointer(y.b), dataOffset)</span><br><span class="line">			y.e = add(y.k, bucketCnt*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 遍历桶中所有元素，迁移数据</span></span><br><span class="line">		<span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">			k := add(unsafe.Pointer(b), dataOffset)</span><br><span class="line">			e := add(k, bucketCnt*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">			<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; bucketCnt; i, k, e = i+<span class="number">1</span>, add(k, <span class="type">uintptr</span>(t.keysize)), add(e, <span class="type">uintptr</span>(t.elemsize)) &#123;</span><br><span class="line">				top := b.tophash[i]</span><br><span class="line">				<span class="keyword">if</span> isEmpty(top) &#123; <span class="comment">// 为空则表示搬移完成该桶</span></span><br><span class="line">					b.tophash[i] = evacuatedEmpty <span class="comment">// 将桶设置为已搬离完成标记</span></span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> top &lt; minTopHash &#123;</span><br><span class="line">					throw(<span class="string">&quot;bad map state&quot;</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				k2 := k</span><br><span class="line">				<span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">					k2 = *((*unsafe.Pointer)(k2))</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">var</span> useY <span class="type">uint8</span></span><br><span class="line">				<span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">					<span class="comment">// 计算落在x还是y，如果非等量扩容的化</span></span><br><span class="line">					hash := t.hasher(k2, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line">                    <span class="keyword">if</span> h.flags&amp;iterator != <span class="number">0</span> &amp;&amp; !t.reflexivekey() &amp;&amp; !t.key.equal(k2, k2) &#123;</span><br><span class="line">                        <span class="comment">// 有一个特殊情况: 有一种 key, 每次对它计算 hash, 得到的结果都不一样，即NaN，这个 key 是永远不会被 Get 操作获取的，当使用 m[math.NaN()] 语句的时候, 是查不出来结果的，这个 key 只有在遍历整个 map 的时候, 才能被找到。并且, 可以向一个 map 插入多个数量的 math.NaN() 作为 key, 它们并不会被互相覆盖。所以当碰到NaN时可以自由选择放到x还是y中，这边直接用tophash最低为来决定分配到x还是y（均匀分布）</span></span><br><span class="line">						useY = top &amp; <span class="number">1</span></span><br><span class="line">						top = tophash(hash)</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="keyword">if</span> hash&amp;newbit != <span class="number">0</span> &#123;</span><br><span class="line">							useY = <span class="number">1</span></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			</span><br><span class="line">				<span class="keyword">if</span> evacuatedX+<span class="number">1</span> != evacuatedY || evacuatedX^<span class="number">1</span> != evacuatedY &#123;</span><br><span class="line">					throw(<span class="string">&quot;bad evacuatedN&quot;</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				b.tophash[i] = evacuatedX + useY <span class="comment">// 设置旧数据标记位，标识已搬移到x还是y</span></span><br><span class="line">				dst := &amp;xy[useY]                 <span class="comment">// 搬移目标x或者y</span></span><br><span class="line">				<span class="comment">// 桶中最后一个元素，需要创建溢出桶继续</span></span><br><span class="line">				<span class="keyword">if</span> dst.i == bucketCnt &#123;</span><br><span class="line">					dst.b = h.newoverflow(t, dst.b)</span><br><span class="line">					dst.i = <span class="number">0</span></span><br><span class="line">					dst.k = add(unsafe.Pointer(dst.b), dataOffset)</span><br><span class="line">					dst.e = add(dst.k, bucketCnt*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">				&#125;</span><br><span class="line">                <span class="comment">// 搬移原来对象</span></span><br><span class="line">                <span class="comment">// 这边不直接使用dst.i是为了避免边界检查，一个小优化</span></span><br><span class="line">				dst.b.tophash[dst.i&amp;(bucketCnt<span class="number">-1</span>)] = top</span><br><span class="line">				<span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">					*(*unsafe.Pointer)(dst.k) = k2</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					typedmemmove(t.key, dst.k, k)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> t.indirectelem() &#123;</span><br><span class="line">					*(*unsafe.Pointer)(dst.e) = *(*unsafe.Pointer)(e)</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					typedmemmove(t.elem, dst.e, e)</span><br><span class="line">				&#125;</span><br><span class="line">				dst.i++</span><br><span class="line">				<span class="comment">// 更新到下一个位置，这里可能越界，但是存储末端有溢出指针，可以防止指向存储桶的末端</span></span><br><span class="line">				dst.k = add(dst.k, <span class="type">uintptr</span>(t.keysize))</span><br><span class="line">				dst.e = add(dst.e, <span class="type">uintptr</span>(t.elemsize))</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果没有在使用旧桶, 就对旧桶进行清理, 用于帮助gc</span></span><br><span class="line">		<span class="keyword">if</span> h.flags&amp;oldIterator == <span class="number">0</span> &amp;&amp; t.bucket.ptrdata != <span class="number">0</span> &#123;</span><br><span class="line">			b := add(h.oldbuckets, oldbucket*<span class="type">uintptr</span>(t.bucketsize))</span><br><span class="line">			<span class="comment">// 保留tophash因为tophash有搬移状态</span></span><br><span class="line">			ptr := add(b, dataOffset)</span><br><span class="line">			n := <span class="type">uintptr</span>(t.bucketsize) - dataOffset</span><br><span class="line">			memclrHasPointers(ptr, n)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 更新搬移进度</span></span><br><span class="line">	<span class="keyword">if</span> oldbucket == h.nevacuate &#123;</span><br><span class="line">		advanceEvacuationMark(h, t, newbit)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看一下更新搬移进度的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">advanceEvacuationMark</span><span class="params">(h *hmap, t *maptype, newbit <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 搬迁桶的进度加一</span></span><br><span class="line">    h.nevacuate++</span><br><span class="line">    <span class="comment">// 实验表明, 1024至少会比newbit高出一个数量级 (newbit代表扩容之前老的bucket个数). </span></span><br><span class="line">    <span class="comment">// 往后遍历n个桶，并确保O(1)时间复杂，所以, 用当前进度加上1024用于确保O(1)行为.</span></span><br><span class="line">    stop := h.nevacuate + <span class="number">1024</span></span><br><span class="line">    <span class="keyword">if</span> stop &gt; newbit &#123;</span><br><span class="line">        stop = newbit</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算已经搬迁完的桶数</span></span><br><span class="line">    <span class="keyword">for</span> h.nevacuate != stop &amp;&amp; bucketEvacuated(t, h, h.nevacuate) &#123;</span><br><span class="line">        h.nevacuate++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果h.nevacuate == newbit, 则代表所有的桶都已经搬迁完毕</span></span><br><span class="line">    <span class="keyword">if</span> h.nevacuate == newbit &#123;</span><br><span class="line">        <span class="comment">// 搬迁完毕，所以指向老的buckets的指针置为nil</span></span><br><span class="line">        h.oldbuckets = <span class="literal">nil</span></span><br><span class="line">        <span class="comment">// 在讲解hmap的结构中, 有过说明. 如果key和value均不包含指针, 且可以inline.</span></span><br><span class="line">        <span class="comment">// 那么保存它们的buckets数组其实是挂在hmap.extra中的. </span></span><br><span class="line">        <span class="comment">// 所以, 这种情况下, 其实我们是搬迁的extra的buckets数组. 因此, 在这种情况下, 需要在搬迁完毕后, 将</span></span><br><span class="line">        <span class="comment">// hmap.extra.oldoverflow指针置为nil.</span></span><br><span class="line">        <span class="keyword">if</span> h.extra != <span class="literal">nil</span> &#123;</span><br><span class="line">            h.extra.oldoverflow = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后, 清除正在扩容的标志位, 扩容完毕.</span></span><br><span class="line">        h.flags &amp;^= sameSizeGrow</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>增量扩容下 map 搬移的图解, 其中 B=3, oldbuckets 数组是8. buckets数组是16</p>
<p><img src="https://pic2.zhimg.com/80/v2-b9ec34eb72d442b4fe95717272781575_1440w.webp" alt="img" /></p>
<p>等量扩容下 map 搬移的图解, 其中 B=3, oldbuckets, buckets数组都是8</p>
<p><img src="https://pic1.zhimg.com/80/v2-810315f7da2ad54fe3ff34dc87b0e18c_1440w.webp" alt="img" /></p>
<p>通过前面分析，可以得知扩容的大致过程。再总结一下一些注意项：</p>
<ul>
<li>根据需扩容的原因不同（overLoadFactor/tooManyOverflowBuckets），分为两类容量规则方向，为等量扩容（不改变原有大小）或双倍扩容。</li>
<li>新申请的扩容空间（newbuckets/newoverflow）都是预分配，等真正使用的时候才会初始化。</li>
<li>扩容完毕后（预分配），不会马上就进行迁移。而是采取<strong>增量扩容</strong>的方式，当有访问到具体 bukcet 时，才会逐渐的进行迁移（将 oldbucket 迁移到 bucket）。</li>
<li>如果扩容中又触发扩容了，会不断<code>goto again</code> ，不断地进行迁移。待迁移完毕后才会开始进行下一次的扩容动作。</li>
</ul>
<h2 id="删除和清空"><a class="markdownIt-Anchor" href="#删除和清空"></a> 删除和清空</h2>
<h3 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h3>
<p>删除操作也同样类似于查找，这边忽略相似代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapdelete</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> &#123;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">search:</span><br><span class="line">	<span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">			...</span><br><span class="line">            <span class="comment">// 到这里已经找到对应的kv了</span></span><br><span class="line">			<span class="comment">// 清除key.</span></span><br><span class="line">			<span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">				*(*unsafe.Pointer)(k) = <span class="literal">nil</span></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> t.key.ptrdata != <span class="number">0</span> &#123;</span><br><span class="line">				memclrHasPointers(k, t.key.size)</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">// 清除elem</span></span><br><span class="line">			e := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+i*<span class="type">uintptr</span>(t.elemsize))</span><br><span class="line">			<span class="keyword">if</span> t.indirectelem() &#123;</span><br><span class="line">				*(*unsafe.Pointer)(e) = <span class="literal">nil</span></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> t.elem.ptrdata != <span class="number">0</span> &#123;</span><br><span class="line">				memclrHasPointers(e, t.elem.size)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				memclrNoHeapPointers(e, t.elem.size)</span><br><span class="line">			&#125;</span><br><span class="line">			b.tophash[i] = emptyOne <span class="comment">// 设置为空标记</span></span><br><span class="line">			<span class="comment">// 如果都为空，则需要设置或更新emptyRest标记</span></span><br><span class="line">			<span class="keyword">if</span> i == bucketCnt<span class="number">-1</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> b.overflow(t) != <span class="literal">nil</span> &amp;&amp; b.overflow(t).tophash[<span class="number">0</span>] != emptyRest &#123;</span><br><span class="line">					<span class="keyword">goto</span> notLast</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> b.tophash[i+<span class="number">1</span>] != emptyRest &#123;</span><br><span class="line">					<span class="keyword">goto</span> notLast</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				b.tophash[i] = emptyRest</span><br><span class="line">				<span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> b == bOrig &#123;</span><br><span class="line">						<span class="keyword">break</span> <span class="comment">// beginning of initial bucket, we&#x27;re done.</span></span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// Find previous bucket, continue at its last entry.</span></span><br><span class="line">					c := b</span><br><span class="line">					<span class="keyword">for</span> b = bOrig; b.overflow(t) != c; b = b.overflow(t) &#123;</span><br><span class="line">					&#125;</span><br><span class="line">					i = bucketCnt - <span class="number">1</span></span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					i--</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> b.tophash[i] != emptyOne &#123;</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;	    </span><br><span class="line">		notLast:</span><br><span class="line">			h.count--</span><br><span class="line">			<span class="comment">// 重置哈希种子，使攻击者更难重复触发哈希冲突。参阅issue 25237</span></span><br><span class="line">			<span class="keyword">if</span> h.count == <span class="number">0</span> &#123;</span><br><span class="line">				h.hash0 = fastrand()</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span> search</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码中还有一个函数<code>mapclear</code>，当使用循环删除所有的kv时，编译器会做优化，将其使用该方法进行清空。</p>
<h1 id="实现支持任意类型kv"><a class="markdownIt-Anchor" href="#实现支持任意类型kv"></a> 实现支持任意类型kv</h1>
<p>Go map是可以接收不同类型的kv的，那在没有泛型的时候它是怎么实现的？</p>
<p><strong>Go运行时是否使用interface{}？</strong><br />不，Go 运行时不用于interface{}实现其map。虽然我们有<code>container/&#123;list,heap&#125;</code>使用空接口的包，但运行时的map实现不使用interface{}.<br /><strong>编译器是否使用代码生成？</strong><br />不，Go 二进制文件中只有一份map实现的副本。只有一种实现，并且与 Java 不同，它不使用interface{}装箱。那么它是怎样工作的？<br />答案有两个部分，它们都涉及编译器和运行时之间的合作。</p>
<h1 id="编译时重写"><a class="markdownIt-Anchor" href="#编译时重写"></a> 编译时重写</h1>
<p>在编译期间，map操作被重写为对运行时的调用。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v := m[<span class="string">&quot;key&quot;</span>] 	  <span class="comment">// runtime.mapaccess1(m, ”key&quot;, &amp;v)</span></span><br><span class="line">v, ok := m[<span class="string">&quot;key&quot;</span>] <span class="comment">// runtime.mapaccess2(m, ”key”, &amp;v, &amp;ok)</span></span><br><span class="line">m[<span class="string">&quot;key&quot;</span>] = <span class="number">9001</span>   <span class="comment">// runtime.mapinsert(m, ”key&quot;, 9001)</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">&quot;key&quot;</span>)  <span class="comment">// runtime.mapdelete(m, “key”)</span></span><br></pre></td></tr></table></figure>
<p>类似的实现还有chan，但是slice不是。</p>
<h1 id="运行时调用"><a class="markdownIt-Anchor" href="#运行时调用"></a> 运行时调用</h1>
<p>说了编译期间，再来看看运行时不使用interface又是如何解析具体类型的。</p>
<p>我们来回顾函数签名<code>mapaccess1</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccess1</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>t是一个指向runtime.maptype结构的指针</p>
<p>那么可以猜到，<em>maptype就是使</em>hmap适用于（几乎）键和值类型的任何组合的原因。maptype中每个唯一的映射声明都有一个值。将会有一个描述从strings到ints、从strings到http.Headers等的映射。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> maptype <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ    _type</span><br><span class="line">	key    *_type</span><br><span class="line">	elem   *_type</span><br><span class="line">	bucket *_type <span class="comment">// internal type representing a hash bucket</span></span><br><span class="line">	<span class="comment">// function for hashing keys (ptr to key, seed) -&gt; hash</span></span><br><span class="line">	hasher     <span class="function"><span class="keyword">func</span><span class="params">(unsafe.Pointer, <span class="type">uintptr</span>)</span></span> <span class="type">uintptr</span></span><br><span class="line">	keysize    <span class="type">uint8</span>  <span class="comment">// size of key slot</span></span><br><span class="line">	elemsize   <span class="type">uint8</span>  <span class="comment">// size of elem slot</span></span><br><span class="line">	bucketsize <span class="type">uint16</span> <span class="comment">// size of bucket</span></span><br><span class="line">	flags      <span class="type">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个maptype都包含有关从key到elem的此类映射的属性的详细信息。它包含有关key和elem的信息。maptype.key包含有关我们传递的key的指针的信息。我们称这些为<strong>类型描述符</strong>。<br />到此为止，大概可以理解，为什么map可以处理几乎任意类型了。</p>
<h1 id="辅助函数"><a class="markdownIt-Anchor" href="#辅助函数"></a> 辅助函数</h1>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mt *maptype)</span></span> indirectkey() <span class="type">bool</span> <span class="comment">// 是否直接存储key，即没有指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mt *maptype)</span></span> indirectelem() <span class="type">bool</span> <span class="comment">// 是否直接存储elem，即没有指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bucketShift</span><span class="params">(b <span class="type">uint8</span>)</span></span> <span class="type">uintptr</span> <span class="comment">// 2^b, b的有效范围[0-63]</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bucketMask</span><span class="params">(b <span class="type">uint8</span>)</span></span> <span class="type">uintptr</span> <span class="comment">// 2^b-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取tophash</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tophash</span><span class="params">(hash <span class="type">uintptr</span>)</span></span> <span class="type">uint8</span> &#123;</span><br><span class="line">    top := <span class="type">uint8</span>(hash &gt;&gt; (sys.PtrSize*<span class="number">8</span> - <span class="number">8</span>))</span><br><span class="line">    <span class="keyword">if</span> top &lt; minTopHash &#123;</span><br><span class="line">        top += minTopHash <span class="comment">// hash值从minTopHash开始，前minTopHash位作为标记位使用，包含扩容状态，槽位状态等</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> top</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建溢出桶</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hmap)</span></span> newoverflow(t *maptype, b *bmap) *bmap &#123;</span><br><span class="line">	<span class="keyword">var</span> ovf *bmap</span><br><span class="line">	<span class="keyword">if</span> h.extra != <span class="literal">nil</span> &amp;&amp; h.extra.nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 如果还有预分配的溢出桶直接使用就行</span></span><br><span class="line">		ovf = h.extra.nextOverflow</span><br><span class="line">		<span class="keyword">if</span> ovf.overflow(t) == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 指针碰撞获取下一个溢出桶位置</span></span><br><span class="line">			h.extra.nextOverflow = (*bmap)(add(unsafe.Pointer(ovf), <span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 如果不为nil说明这是最后一个预分配的溢出桶了，重置存储桶上的溢出指针，该指针设置为非 nil 哨兵值。</span></span><br><span class="line">			ovf.setoverflow(t, <span class="literal">nil</span>)</span><br><span class="line">			h.extra.nextOverflow = <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个新的溢出桶</span></span><br><span class="line">		ovf = (*bmap)(newobject(t.bucket))</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 递增溢出桶数量</span></span><br><span class="line">	h.incrnoverflow()</span><br><span class="line">	<span class="keyword">if</span> t.bucket.ptrdata == <span class="number">0</span> &#123; <span class="comment">// 如果map不存在指针数据，则溢出桶将存储在extra中</span></span><br><span class="line">		h.createOverflow()</span><br><span class="line">		*h.extra.overflow = <span class="built_in">append</span>(*h.extra.overflow, ovf)</span><br><span class="line">	&#125;</span><br><span class="line">	b.setoverflow(t, ovf)</span><br><span class="line">	<span class="keyword">return</span> ovf</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化extra中的overflow</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hmap)</span></span> createOverflow() &#123;</span><br><span class="line">	<span class="keyword">if</span> h.extra == <span class="literal">nil</span> &#123;</span><br><span class="line">		h.extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> h.extra.overflow == <span class="literal">nil</span> &#123;</span><br><span class="line">		h.extra.overflow = <span class="built_in">new</span>([]*bmap)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递增h.noverflow，noverflow 是一个 uint16。当存储桶很少时，noverflow 是一个精确计数。当有许多存储桶时，noverflow 是一个近似计数。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hmap)</span></span> incrnoverflow() &#123;</span><br><span class="line">    <span class="comment">// 前面代码有分析到当溢出桶&gt;15时，只要溢出桶达到2^15次方则会触发扩容，所以只要保证B&lt;16时，noverflow为精确计数</span></span><br><span class="line">	<span class="keyword">if</span> h.B &lt; <span class="number">16</span> &#123;</span><br><span class="line">		h.noverflow++</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 否则概率性递增，（这个操作类似redis中的lfu计数）</span></span><br><span class="line">	mask := <span class="type">uint32</span>(<span class="number">1</span>)&lt;&lt;(h.B<span class="number">-15</span>) - <span class="number">1</span></span><br><span class="line">	<span class="comment">// Example: if h.B == 18, then mask == 7,</span></span><br><span class="line">	<span class="comment">// and fastrand &amp; 7 == 0 with probability 1/8.</span></span><br><span class="line">	<span class="keyword">if</span> fastrand()&amp;mask == <span class="number">0</span> &#123;</span><br><span class="line">		h.noverflow++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<p>Go的map源码还是有很多细节可以扣的，可以学到很多小细节，还是很推荐阅读的！</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">fish</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://fishx233.github.io/2023/04/10/Go map实现/">https://fishx233.github.io/2023/04/10/Go map实现/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2023/05/05/actor%E6%A8%A1%E5%9E%8B/"><i class="fa fa-chevron-left">  </i><span>actor模型</span></a></div><div class="next-post pull-right"><a href="/2023/03/09/visual-chatgpt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><span>visual-chatgpt源码分析</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(/media/101485281_p0_master1200.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2024 By fish</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>