<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Go与范型"><meta name="keywords" content=""><meta name="author" content="Fish"><meta name="copyright" content="Fish"><title>Go与范型 | Fish</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.3.0'
} </script><meta name="generator" content="Hexo 6.3.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.</span> <span class="toc-text"> 泛型实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text"> 什么是泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text"> 实现泛型的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text"> 手动泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E5%A4%8D%E5%88%B6%E4%BB%A3%E7%A0%81"><span class="toc-number">1.2.1.1.</span> <span class="toc-text"> 手动复制&#x2F;代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E5%8F%8D%E5%B0%84"><span class="toc-number">1.2.1.2.</span> <span class="toc-text"> 类型断言&#x2F;反射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">1.2.1.3.</span> <span class="toc-text"> 指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E6%80%81%E5%8C%96"><span class="toc-number">1.2.2.</span> <span class="toc-text"> 单态化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="toc-number">1.2.3.</span> <span class="toc-text"> 类型擦除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E7%AE%B1"><span class="toc-number">1.2.4.</span> <span class="toc-text"> 装箱</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go%E7%9A%84%E4%B8%89%E7%A7%8D%E6%B3%9B%E5%9E%8B%E5%AE%9E%E7%8E%B0%E6%8F%90%E6%A1%88"><span class="toc-number">1.3.</span> <span class="toc-text"> Go的三种泛型实现提案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E5%85%B8"><span class="toc-number">1.3.1.</span> <span class="toc-text"> 字典</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%9C%A1%E5%8D%B0"><span class="toc-number">1.3.2.</span> <span class="toc-text"> 蜡印</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gc-shape"><span class="toc-number">1.3.3.</span> <span class="toc-text"> GC Shape（混合）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81go%E6%B3%9B%E5%9E%8B%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.</span> <span class="toc-text"> 验证Go泛型实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%88%86%E6%9E%90"><span class="toc-number">1.4.1.</span> <span class="toc-text"> 调用分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gc-share%E7%B1%BB%E5%9E%8B%E8%A7%A3%E6%9E%90"><span class="toc-number">1.4.2.</span> <span class="toc-text"> GC Share类型解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%8E%B0"><span class="toc-number">1.4.3.</span> <span class="toc-text"> 表现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#go%E6%B3%9B%E5%9E%8B%E4%BD%BF%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text"> Go泛型使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">2.1.</span> <span class="toc-text"> 基本语法和使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-number">2.2.</span> <span class="toc-text"> 泛型约束</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#any%E7%BA%A6%E6%9D%9F"><span class="toc-number">2.2.1.</span> <span class="toc-text"> any约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%BA%A6%E6%9D%9F"><span class="toc-number">2.2.2.</span> <span class="toc-text"> 函数约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F-2"><span class="toc-number">2.2.3.</span> <span class="toc-text"> 泛型约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E7%BA%A6%E6%9D%9F"><span class="toc-number">2.2.4.</span> <span class="toc-text"> 运算符约束</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-number">2.3.</span> <span class="toc-text"> 泛型推导</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9E%E5%8F%82%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BCfunction-argument-type-inference"><span class="toc-number">2.3.1.</span> <span class="toc-text"> 函数实参类型推导(Function argument type inference)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BCconstraint-type-inference"><span class="toc-number">2.3.2.</span> <span class="toc-text"> 约束类型推导(Constraint type inference)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Ego%E5%BC%95%E5%85%A5%E6%B3%9B%E5%9E%8B%E7%9A%84%E8%AE%A8%E8%AE%BA"><span class="toc-number">3.</span> <span class="toc-text"> 关于Go引入泛型的讨论</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB"><span class="toc-number">4.</span> <span class="toc-text"> 扩展阅读</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#go-map%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.1.</span> <span class="toc-text"> Go map实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6%E9%87%8D%E5%86%99"><span class="toc-number">4.1.1.</span> <span class="toc-text"> 编译时重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E8%B0%83%E7%94%A8"><span class="toc-number">4.1.2.</span> <span class="toc-text"> 运行时调用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-number">5.</span> <span class="toc-text"> 结语</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%88%96%E5%BB%B6%E4%BC%B8%E9%98%85%E8%AF%BB"><span class="toc-number">6.</span> <span class="toc-text"> 引用或延伸阅读</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Fish</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">6</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Fish</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Go与范型</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-06-12</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><meta name="referrer" content="no-referrer" />
<p>本文相关代码均<strong>基于Go1.18</strong><br />
<a name="DjwaJ"></a></p>
<h1 id="泛型实现"><a class="markdownIt-Anchor" href="#泛型实现"></a> 泛型实现</h1>
<p><a name="AZJRG"></a></p>
<h2 id="什么是泛型"><a class="markdownIt-Anchor" href="#什么是泛型"></a> 什么是泛型</h2>
<p>Form wiki</p>
<blockquote>
<p>Generic programming is a style of computer programming in which algorithms are written in terms of data types to-be-specified-later that are then instantiated when needed for specific types provided as parameters. This approach, pioneered by the ML programming language in 1973,[1][2] permits writing common functions or types that differ only in the set of types on which they operate when used, thus reducing duplicate code.</p>
</blockquote>
<p><a name="ZM0O7"></a></p>
<h2 id="实现泛型的方式"><a class="markdownIt-Anchor" href="#实现泛型的方式"></a> 实现泛型的方式</h2>
<p>编程语言实现泛型具体化（又名参数多态性指的是声明与定义函数、复合类型、变量时不指定其具体的类型，而把这部分类型作为参数使用，使得该定义对各种具体类型都适用。）的方法有很多，但我们主要关注下面几个方案。<br />
<a name="Vva8r"></a></p>
<h3 id="手动泛型"><a class="markdownIt-Anchor" href="#手动泛型"></a> 手动泛型</h3>
<p>所谓手动泛型，就是。。。纯手撸👋，在Go没有支持类型参数（Type Parameter）前，基本都是用这种形式来实现泛型。<br />
<a name="fwyYd"></a></p>
<h4 id="手动复制代码"><a class="markdownIt-Anchor" href="#手动复制代码"></a> 手动复制/代码</h4>
<p>经典动图，一图胜千言。<br />当然这种实现也有它的优势，例如：性能高，可读性高，不需要做额外的类型检查等。<br /><img src="https://cdn.nlark.com/yuque/0/2023/gif/1487474/1688552355211-3aa10c0f-781b-4c1a-a788-4b85d8580525.gif#averageHue=%23272822&amp;clientId=u2224d895-6427-4&amp;from=paste&amp;id=ud6ef66a4&amp;originHeight=588&amp;originWidth=545&amp;originalType=url&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u970932ed-da12-44c6-a1c4-7517649a71a&amp;title=" alt="" /><br />
<a name="DsPEw"></a></p>
<h4 id="类型断言反射"><a class="markdownIt-Anchor" href="#类型断言反射"></a> 类型断言/反射</h4>
<p>通过传入interface参数来实现参数化类型，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func min(a, b interface&#123;&#125;) bool &#123;</span><br><span class="line">   switch v1 := a.(type) &#123;</span><br><span class="line">   case int:</span><br><span class="line">      return v1 &lt; b.(int)</span><br><span class="line">   case int32:</span><br><span class="line">      return v1 &lt; b.(int32)</span><br><span class="line">   &#125;</span><br><span class="line">   return false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="WyzAB"></a></p>
<h4 id="指针"><a class="markdownIt-Anchor" href="#指针"></a> 指针</h4>
<p>在同样不支持泛型的C语言中，我们通过*Void类型指针手动计算位移地址来实现。例如：<br />
<a name="MUrgS"></a></p>
<h3 id="单态化"><a class="markdownIt-Anchor" href="#单态化"></a> 单态化</h3>
<p>进行单态化最直接的方法之一是多次复制代码以实现不同的类型具体化——将多态转换为具体函数。这可以提高运行时性能，但会产生编译时成本，并可能产生臃肿的二进制文件。它适用于像 Rust，C++和C#这样的语言。<br />
<a name="swMvA"></a></p>
<h3 id="类型擦除"><a class="markdownIt-Anchor" href="#类型擦除"></a> 类型擦除</h3>
<p>熟悉Java的都知道，Java 的泛型仅存在于源代码中，并且会在运行时动态类型擦除为Object。虽然代码不冗余并且节省了空间，但是拆箱与装箱操作会减慢执行速度。类型擦除也给Java的泛型带来了很多的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Generics_in_Java#Problems_with_type_erasure">限制</a>。<br />
<a name="wkr2s"></a></p>
<h3 id="装箱"><a class="markdownIt-Anchor" href="#装箱"></a> 装箱</h3>
<p>在装箱中，“值”被装箱并作为多态类型的引用传递，通常使用指针表，通常称为虚拟表。这就是Go的interface的实现方式。这通常会生成较小的二进制文件，并且需要较短的编译时间，但可能会影响运行时性能。<br />
<a name="uDk46"></a></p>
<h2 id="go的三种泛型实现提案"><a class="markdownIt-Anchor" href="#go的三种泛型实现提案"></a> Go的三种泛型实现提案</h2>
<p>Go的实现方式也算可以归到单态化一类中。Go团队针对泛型实现一共提出了三个方案分别是：字典，蜡印，GC shape。<br />
<a name="qc3eJ"></a></p>
<h3 id="字典"><a class="markdownIt-Anchor" href="#字典"></a> <a target="_blank" rel="noopener" href="https://github.com/golang/proposal/blob/master/design/generics-implementation-dictionaries.md">字典</a></h3>
<p>当为泛型函数生成代码的时候，会生成唯一的一块代码，并且会在参数列表中增加一个字典做参数。字典是描述参数化类型所采用的具体类型的一组信息。当然，它包括具体类型本身，但也包括派生信息。<br />但是处理这样的字典并不是一件容易的事，因为还需要考虑泛型类型、派生类型和潜在的子字典。<br />另一种选择则是在字典中包含每个函数调用的每个参数/返回值所需的偏移量f(有点类似C的泛型实现)。<br />此外，还有其他潜在的问题。例如，字典是否用数组实现，是否需要排序，字典是否允许递归或自引用，以及如何让底层寄存器轻松处理不同的数据类型，比例单态化性能会慢多少等等等等。<br />
<a name="rCruf"></a></p>
<h3 id="蜡印"><a class="markdownIt-Anchor" href="#蜡印"></a> <a target="_blank" rel="noopener" href="https://github.com/golang/proposal/blob/master/design/generics-implementation-stenciling.md">蜡印</a></h3>
<p>与上述字典相反。相同的泛型函数为每个实例化的类型参数生成一组独立的代码。<br />因为编译f时是不知道它的实例化类型的，只有在调用它时才知道它的实例化的类型，所以需要在调用时编译f。对于相同实例化类型的多个调用，同一个package下编译器可以识别出来是一样的，只生成一个代码就可以了，但是不同的package就不简单了，这些函数表标记为DUPOK,所以链接器会丢掉重复的函数实现。<br />显然，这种策略有两个缺点。首先，由于需要编译泛型函数多次，所以需要更多的编译时间。其次，因为对于同一个泛型函数，每种类型需要单独的一份编译的代码，如果类型非常多，编译的文件可能非常大，而且性能也比较差。<br />
<a name="feWxS"></a></p>
<h3 id="gc-shape"><a class="markdownIt-Anchor" href="#gc-shape"></a> <a target="_blank" rel="noopener" href="https://github.com/golang/proposal/blob/master/design/generics-implementation-gcshape.md">GC Shape</a>（混合）</h3>
<p>GC Shape可以被视为上述两者的混合。 什么是GC形状？ GC Shape 不是一般的数据类型，而是编译器中处理内存分配/垃圾收集的类型。包括它的大小、所需的对齐方式、以及类型哪些部分包含指针。 用一个例子来更好地解释。int、uint32、 和int32 在某些编译器中具有相同的底层实现。即初始化变量时占用相同数量的内存地址。 <br />在实现中，每个GC shape都会生成一组代码，每组代码都携带一个包含实例化类型信息的字典。因此，与第一种方案相比，它大大减少了模板代码量，并降低了处理字典中的派生类型和实例化类型的复杂度。 <br />然而，它也存在风险。与完全模板化相比，可以减少的代码量是不可控的，并且编译器事先不知道如何使用泛型。因此，一旦减少有限但字典复杂度增加，这似乎并不是个明智的选择。<br />
<a name="tqpuh"></a></p>
<h2 id="验证go泛型实现"><a class="markdownIt-Anchor" href="#验证go泛型实现"></a> 验证Go泛型实现</h2>
<p><a name="DfiDK"></a></p>
<h3 id="调用分析"><a class="markdownIt-Anchor" href="#调用分析"></a> 调用分析</h3>
<p>上面介绍了Go的三种泛型实现的提案，现在我们来通过检查二进制文件验证一下，到底使用了哪一种方案。<br />先来看一段代码：<br />然后我们通过lensm来看下汇编（记得关闭编译优化）<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/1487474/1688552355242-7ac28bb9-5a78-4e82-9898-903b3bfbbe7a.png#averageHue=%23f5e6d7&amp;clientId=u2224d895-6427-4&amp;from=paste&amp;id=u29046497&amp;originHeight=762&amp;originWidth=2786&amp;originalType=url&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u29a1929e-2fd3-4a49-851a-0d95f0834cd&amp;title=" alt="" /><br />可以看到foo(123)调用了main.foo[go.shape.int_0]，foo(“xiaodaniubi”)则调用了main.foo[go.shape.string_0]。<br />所有的shage都放入名为go.shape的内置包中。编译器还将类型参数索引包含到shape中。int shape的基础类型可能是go.shape.int_0或go.shape.int_1，具体取决于类型参数是用作第一个参数还是第二个参数。<br />此外，所有指针类型共享相同的GC shape，即<em>int和</em>string生成相同的代码并且不是单态的。对于interface来说也是如此。我们再看下面一段代码，来验证一下这个设想：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/1487474/1688552355292-08912ec7-e858-4be0-bdd0-294a85fba12a.png#averageHue=%23f0eebe&amp;clientId=u2224d895-6427-4&amp;from=paste&amp;id=u96ce5e0a&amp;originHeight=932&amp;originWidth=2776&amp;originalType=url&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u26c5021f-c824-4215-a098-e9edcf3efb0&amp;title=" alt="" /><br />可以注意到几个点：</p>
<ul>
<li>foo(&amp;a)和foo(&amp;b)使用了相同的shape，都是调用了main.foo[go.shape.*uint8_0]。</li>
<li>baz(&amp;Bar{})调用main.baz[go.shape.*uint8_0]。可以看到，Bar的main.baz并不是单态的，所有接口类型共享相同的GC Shape。</li>
</ul>
<p>通过上述代码，大致可以确认，Go使用的方式就是GC Shape，当然也可以Go提案中也明确了，使用了GC Share，可以参考：<a target="_blank" rel="noopener" href="https://github.com/golang/proposal/blob/master/design/generics-implementation-dictionaries-go1.18.md">https://github.com/golang/proposal/blob/master/design/generics-implementation-dictionaries-go1.18.md</a><br />
<a name="a4dlK"></a></p>
<h3 id="gc-share类型解析"><a class="markdownIt-Anchor" href="#gc-share类型解析"></a> GC Share类型解析</h3>
<p>那么相同的GC shape如何进行解析的呢？这时候就要用到前面说的提案一之字典了，细心的同学可能已经发送了，前面的汇编中有这样一段内容：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/1487474/1688552355202-79b3081c-2e2a-4d8d-9334-ee51eb286cc5.png#averageHue=%23c9dcea&amp;clientId=u2224d895-6427-4&amp;from=paste&amp;id=u462134a8&amp;originHeight=306&amp;originWidth=676&amp;originalType=url&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1e714f7e-f80e-4ea6-bbb5-eb99f59dc27&amp;title=" alt="" /><br />对于x86_64，可以看到字典被传递到AX寄存器中。Go 使用当前泛型实现将字典传递给被调用函数。该字典包含用于解析方法并将其与interface相互转换的所有元数据。<br />再看下方法的汇编：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/1487474/1688552355197-0f7d064b-94e9-4ebe-af75-5a227621007b.png#averageHue=%23f6f3f0&amp;clientId=u2224d895-6427-4&amp;from=paste&amp;id=u567cf057&amp;originHeight=1256&amp;originWidth=2558&amp;originalType=url&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u276ff6b6-2b39-4509-885c-22782c636f3&amp;title=" alt="" /><br />可以看到，在调用data.Stuff()之前，运行时使用寄存器AX中存储的字典解析函数地址。寄存器AX中会存储的字典解析函数地址。这类似于接口的“虚拟”方法调用的工作方式。<br />字典在编译时静态定义，并以泛型函数的完全限定名称和类型参数的名称命名。编译器会删除具有相同名称的字典的重复数据。<br />
<a name="qpgtJ"></a></p>
<h3 id="表现"><a class="markdownIt-Anchor" href="#表现"></a> 表现</h3>
<p>使用泛型重写基于接口的 API 可以提高性能，但由于使用字典进行方法解析，也有可能会损害性能。</p>
<ul>
<li>[ ] <strong>todo 未完待续</strong><a href="/ouwei-3zruh">@普通的咸鱼(ouwei-3zruh)</a><br />
<a name="v2gV3"></a></li>
</ul>
<h1 id="go泛型使用"><a class="markdownIt-Anchor" href="#go泛型使用"></a> Go泛型使用</h1>
<p><a name="FJMgZ"></a></p>
<h2 id="基本语法和使用"><a class="markdownIt-Anchor" href="#基本语法和使用"></a> 基本语法和使用</h2>
<p>泛型在Go语言中增加了三个新的重要内容：</p>
<ul>
<li>函数和类型新增对类型形参(type parameters)的支持。</li>
<li>将接口类型定义为类型集合，包括没有方法的接口类型。</li>
<li>支持类型推导，大多数情况下，调用泛型函数时可省略类型实参(type arguments)。</li>
</ul>
<p>函数和类型（<strong>目前还不支持</strong><a target="_blank" rel="noopener" href="https://github.com/golang/go/issues/49085"><strong>泛型方法</strong></a>）被允许拥有类型形参(Type Parameters)。一个类型形参列表看起来和普通的函数形参列表一样，只不过使用的是方括号而不是小括号。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GMin</span>[<span class="title">T</span> <span class="title">constraints</span>.<span class="title">Ordered</span>]<span class="params">(x, y T)</span></span> T &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	GMin[<span class="type">int</span>](<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">	GMin[<span class="type">int32</span>](<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也可以跟类型一起用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Tree[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">    left, right *Tree[T]</span><br><span class="line">    value       T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tree[T])</span></span> Lookup(x T) *Tree[T] &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stringTree Tree[<span class="type">string</span>]</span><br></pre></td></tr></table></figure>
<p>泛型类型Tree存储了类型参数T的值。泛型类型也可以有方法。<br />
<a name="dgQqP"></a></p>
<h2 id="泛型约束"><a class="markdownIt-Anchor" href="#泛型约束"></a> 泛型约束</h2>
<p>我们再来看上面的min例子，了解一下为什么需要泛型约束。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GMin</span>[<span class="title">T</span> <span class="title">constraints</span>.<span class="title">Ordered</span>]<span class="params">(x, y T)</span></span> T &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意一下这个约束，<code>T constraints.Ordered</code>只有满足支持比较运算符的类型才可以使用这个泛型函数，如果没有泛型约束，自然就无法确定类型支持的方法了。<br />如果某类型约束不限制类型实现的函数，同时也不限制类型支持的运算符，那就意味着对应的类型参数可以接受任意类型。这种特殊的约束就是any（实际就是interface{}的别名，因为官方觉得interface{}又臭又长所以引入了个any）。<br />我们继续看一下刚才用到的<code>constraints.Ordered</code>的定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Ordered <span class="keyword">interface</span> &#123;</span><br><span class="line">    Integer|Float|~<span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ordered接口是所有整数、浮点和字符串类型的集合。竖线<code>|</code>表达了类型（或者说这里是类型集合）的联合(union)。Integer和Float是接口类型，在constraints包中也有类似的定义。注意，Ordered接口没有定义任何方法。<br />对于类型约束，我们通常不关心某一个特定的类型，比如字符串；我们对所有的字符串类型感兴趣。这就是<sub>标记的作用，称为近似约束。表达式</sub>string意味着底层类型(underlying type)为string的所有类型的集合。这包括string类型本身，以及所有用类似type MyString string声明的类型。<br />对于一些简单的使用场景，可以省略interface关键字。比如：<br /><code>type Max[T interface&#123;int|uint&#125;](a, b T) &#123; ... &#125;</code><br />可以直接简化成：<br /><code>type Max[T int|uint](a, b T) &#123; ... &#125;</code><br />
<a name="N7Drm"></a></p>
<h3 id="any约束"><a class="markdownIt-Anchor" href="#any约束"></a> any约束</h3>
<p>即对类型没有任务限制，我们在写代码的时候只能使用所有类型都支持的语法，类似java的Object：</p>
<ul>
<li>声明或者定义变量</li>
<li>同类型变量之前相互赋值</li>
<li>用作函数的参数或者返回值</li>
<li>获取对应变量的地址</li>
<li>将对应变量转换成interface{}或者赋值给interface{}类型的变量</li>
<li>将interface{}类型的变量转换成对应类型的变量: t, ok := v.(T)</li>
<li>在 switch 类型枚举使用对应类型: switch v.(type) { case T: /* … */ }</li>
<li>构造复合类型，比如 []T</li>
<li>传给某些内置函数，比如 p := new(T)<br />
<a name="aIdja"></a></li>
</ul>
<h3 id="函数约束"><a class="markdownIt-Anchor" href="#函数约束"></a> 函数约束</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">interface</span> &#123;</span><br><span class="line">    Baz() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们希望类型参数T所有的取值都实现Baz() string函数时，我们就可以像上面这样定义。<br />
<a name="dttQf"></a></p>
<h3 id="泛型约束-2"><a class="markdownIt-Anchor" href="#泛型约束-2"></a> 泛型约束</h3>
<p>约束也可以包含约束本身<br />
<a name="dvmjT"></a></p>
<h3 id="运算符约束"><a class="markdownIt-Anchor" href="#运算符约束"></a> 运算符约束</h3>
<p>Go语言不允许重载运算符。所以，只能Go语言内置的对象才支持运算符操作。要实现例如&gt;，&lt;等约束，只能通过包含所有可排序的类型进行约束，例如上面的<code>constraints.Ordered</code>，但是有一个特殊的内置约束类型是<code>comparable</code>代表了可比较类型（==，!=），具体哪些可比较可以参考：<a target="_blank" rel="noopener" href="https://go.dev/ref/spec#Comparison_operators">https://go.dev/ref/spec#Comparison_operators</a><br />
<a name="AhT9w"></a></p>
<h2 id="泛型推导"><a class="markdownIt-Anchor" href="#泛型推导"></a> 泛型推导</h2>
<p>最后一个主要的语言新特性是类型推导。在某些方面，这是语言最复杂的变化，但它很重要，因为它让人们在编写调用泛型函数的代码时使用一种更为自然的风格。<br />Go语言支持如下几种情况的类型推导：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Map 对入参 s 切片中的每个元素执行函数 f，将结果保存到新的切片并返回。</span><br><span class="line">// 类型参数 F 和 T 需要在调用的时候指定。</span><br><span class="line">func Map[F, T any](s []F, f func(F) T) []T &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">var s []int</span><br><span class="line">f := func(i int) int64 &#123; return int64(i) &#125;</span><br><span class="line">var r []int64</span><br><span class="line"></span><br><span class="line">// 普通情形，指定全部类型参数</span><br><span class="line">r = Map[int, int64](s, f)</span><br><span class="line"></span><br><span class="line">// 仅指定第一个类型参数，自动推导后面的类型参数</span><br><span class="line">r = Map[int](s, f)</span><br><span class="line"></span><br><span class="line">// 自动推导所有类型参数</span><br><span class="line">r = Map(s, f)</span><br></pre></td></tr></table></figure>
<p>如果在使用泛型函数/类型的时候未指明全部的类型参数，编译器就会尝试推导缺失的类型。如果推导失败则会报编译错误。<br />
<a name="n98t4"></a></p>
<h3 id="函数实参类型推导function-argument-type-inference"><a class="markdownIt-Anchor" href="#函数实参类型推导function-argument-type-inference"></a> 函数实参类型推导(Function argument type inference)</h3>
<p>以上面的自动推导例子来看，在许多情况下，编译器可以从普通参数中推导出T的类型实参。这使得代码更短。其原理是将实际参数a和b的类型与形式参数x和y的类型相匹配。这种从函数的实参类型推导出类型实参的推导方式，被称为<strong>函数实参类型推导</strong>。<br />推导分两个阶段。<br />第一段跳过所有实参中无类型常量匹配一遍。如果还有类型参数没有确定，则将开始第二阶段。此时需要给所有无类型常量设置为对应的默认类型，然后再匹配一遍。同一个类型参数可能被匹配多次，如果多次匹配的类型结果不一致就会报编译错误。<br />有类型参数上面已经看过了，来看一下无类型参数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Boo</span>[<span class="title">F</span> <span class="title">any</span>]<span class="params">(f1, f2 F)</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于<code>Boo(1, 2)</code>会跳过第一阶段，第二阶段给1和2设定默认类型为int。所以类型参数F对应int，该函数调用被推断为<code>Boo[int](1,2)</code>。</li>
<li>对于<code>Boo(1,int64(2))</code>，第一阶段推导忽略无类型常量1。因为第二个参数的类型为int64，所以推断F的参数为int64。所以最终的函数调用为<code>Boo[int64](1,2)</code></li>
<li><code>对于NewPair(1,2.5)</code>，第二阶段先将1和2.5设定默认类型为int和float64。然后从左往右匹配。对于参数1确认F为int，对于参数2.5，确定F为float64。两次结果不相同，所以报错。</li>
</ul>
<p>类型推导完成后，编译器依然会执行约束校验和参数类型检查。<br />
<a name="MSFaZ"></a></p>
<h3 id="约束类型推导constraint-type-inference"><a class="markdownIt-Anchor" href="#约束类型推导constraint-type-inference"></a> 约束类型推导(Constraint type inference)</h3>
<p>假设我们有如下函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MySlice []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(MySlice)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;MySlice&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Double</span>[<span class="title">E</span> <span class="title">constraints</span>.<span class="title">Number</span>]<span class="params">(s []E)</span></span> []E &#123;</span><br><span class="line">	r := <span class="built_in">make</span>([]E, <span class="built_in">len</span>(s))</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		r[i] = v + v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">type</span> MySlice []<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> v = Double(MySlice&#123;<span class="number">1</span>&#125;)</span><br><span class="line">v.String()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面推导出来到的<code>v</code>的类型其实是<code>[]int</code>，而不是我们想要的<code>MySlice</code>。因为编译器在比较<code>MySlice</code>和<code>[]E</code>的时候把<code>MySlice</code>换成了底层类型<code>[]int</code>，所以推导出<code>E</code>为<code>int</code>。<br />为了能让Double正常返回MySlice类型，我们将函数改写成：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SC 限定类型必须为元素类型为 E 的切片。</span></span><br><span class="line"><span class="keyword">type</span> SC[E any] <span class="keyword">interface</span> &#123;</span><br><span class="line">	[]E</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoubleDefined</span>[<span class="title">S</span> <span class="title">SC</span>[<span class="title">E</span>], <span class="title">E</span> <span class="title">constraints</span>.<span class="title">Number</span>]<span class="params">(s S)</span></span> S &#123;</span><br><span class="line">	r := <span class="built_in">make</span>(S, <span class="built_in">len</span>(s))</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		r[i] = v + v</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">var</span> v1 = DoubleDefined[MySlice, <span class="type">int</span>](MySlice&#123;<span class="number">1</span>&#125;)</span><br><span class="line"><span class="comment">// 或者自动推导</span></span><br><span class="line"><span class="keyword">var</span> v2 = DoubleDefined(MySlice&#123;<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>首先，编译器执行函数参数类型推导。此时需要对比<code>MySlice</code>和<code>S</code>，但<code>S</code>使用结构约束，所以需要推导其实际的约束类型。<br />为此，编译器构建一个映射表：<br /><code>&#123;S -&gt; MySlice&#125;</code><br />然后，编译器展开<code>S</code>约束，把<code>SC[E]</code>展开成<code>[]E</code>。因为我们之前记录了<code>S</code>跟<code>MySlice</code>的映射关系，所以可以对比<code>[]E</code>和<code>MySlice</code>。又因为<code>MySlice</code>的底层类型为<code>[]int</code>，所以推导出<code>E</code>的类型为<code>int</code>：<br /><code>&#123;S -&gt; MySlice, E -&gt; int&#125;</code><br />然后，我们把约束中的<code>E</code>都换成<code>int</code>，看还有没有不确定的类型参数。没有了，所以推导结束。所以原来的调用被推导为：<br /><code>var v = DoubleDefined[MySlice,int](MySlice&#123;1&#125;)</code><br />返回的结果依然是<code>MySlice</code>。<br /><strong>指针方法约束示例</strong><br />假设我们希望把一组字符串转换成一组其他类型的数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Setter 限制类型需要实现 Set 方法，通过 string 设置自身的值。</span></span><br><span class="line"><span class="keyword">type</span> Setter <span class="keyword">interface</span> &#123;</span><br><span class="line">	Set(<span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FromStrings 接受字符串切片，返回类型为 T 的切片。</span></span><br><span class="line"><span class="comment">// 返回切片中每个元素的值通过调用其 Set 方法设置。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FromStrings</span>[<span class="title">T</span> <span class="title">Setter</span>]<span class="params">(s []<span class="type">string</span>)</span></span> []T &#123;</span><br><span class="line">	result := <span class="built_in">make</span>([]T, <span class="built_in">len</span>(s))</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		result[i].Set(v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Settable 是可以从字符串设置自身取值的整数类型。</span></span><br><span class="line"><span class="keyword">type</span> Settable <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Set 将字符串解析成整数并赋给 *p。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Settable)</span></span> Set(s <span class="type">string</span>) &#123;</span><br><span class="line">	i, _ := strconv.Atoi(s)</span><br><span class="line">	*p = Settable(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数，无法编译</span></span><br><span class="line">nums := FromStrings[Settable]([]<span class="type">string</span>&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>上面的代码不能正常编译。因为我们指定<code>T</code>的类型为<code>Settable</code>，但<code>Settable</code>类型并没有实现<code>Set(string)</code>方法。实现该方法的是类型<code>*Settable</code>。<br />于是我们将调用代码改成：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用函数，正常编译，但运行报错</span></span><br><span class="line">nums := FromStrings[*Settable]([]<span class="type">string</span>&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>这次可以正常编译，但运行代码又会报错。这是因为在<code>FromStrings</code>中，<code>result[i]</code>的类型为<code>*Settable</code>，值为<code>nil</code>，无法执行<code>*p = *Settable(i)</code>赋值。<br />所以说，上面定义的<code>FromStrings</code>，我们既不能将<code>T</code>定为<code>Settable</code>，这会导致编译错误，又不能定为<code>*Settable</code>，这会导致运行时错误。<br />为了实现<code>FromStrings</code>，我们需要同时指定<code>Settable</code>和<code>*Settable</code>类型，这就需要结构化约束：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Setter2 限制类型必须是 B 的指针而且要实现 Set 方法。</span></span><br><span class="line"><span class="keyword">type</span> Setter2[B any] <span class="keyword">interface</span> &#123;</span><br><span class="line">	Set(<span class="type">string</span>)</span><br><span class="line">	*B</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FromStrings2 接受字符串切片，返回 T 切片。</span></span><br><span class="line"><span class="comment">// 这里定义了两个类型参数，所以才能在返回 T 切片的同时</span></span><br><span class="line"><span class="comment">// 调用 *T 也就是 PT 的方法。</span></span><br><span class="line"><span class="comment">// Setter2 约束可以确保 PT 是 T 的指针。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FromStrings2</span>[<span class="title">T</span> <span class="title">any</span>, <span class="title">PT</span> <span class="title">Setter2</span>[<span class="title">T</span>]]<span class="params">(s []<span class="type">string</span>)</span></span> []T &#123;</span><br><span class="line">	result := <span class="built_in">make</span>([]T, <span class="built_in">len</span>(s))</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		<span class="comment">// &amp;result[i] 类型是 *T，也就是 Setter2 的类型。</span></span><br><span class="line">		<span class="comment">// 所以可以将其强转为 PT。</span></span><br><span class="line">		p := PT(&amp;result[i])</span><br><span class="line">		<span class="comment">// PT 实现了 Set 方法</span></span><br><span class="line">		p.Set(v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用代码如下：</span></span><br><span class="line">nums := FromStrings2[Settable, *Settable]([]<span class="type">string</span>&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>&#125;)</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="comment">// 因为函数入参中没有使用 T，所以无法进一步简化</span></span><br><span class="line">nums := FromStrings2[Settable]([]<span class="type">string</span>&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>整个编译器的推导过程是这样的。首先，根据已知类型构造映射表：<br /><code>&#123;T -&gt; Settable&#125;</code><br />然后用<code>Settable</code>替换<code>T</code>，展开所有结构化参数。所以<code>PT</code>的类型<code>Setter2[T]</code>被展开成<code>*T</code>，加入到映射表：<br /><code>&#123;T -&gt; Settable, PT -&gt; *T&#125;</code><br />然后把所有<code>T</code>替换成<code>Settable</code>，最终得到：<br /><code>&#123;T -&gt; Settable, PT -&gt; *Settable&#125;</code><br />到此推导结束，实际的函数调用为<code>FromStrings2[Settable,*Settable]([]string&#123;&quot;1&quot;,&quot;2&quot;&#125;)</code>。<br />
<a name="xaGSc"></a></p>
<h1 id="关于go引入泛型的讨论"><a class="markdownIt-Anchor" href="#关于go引入泛型的讨论"></a> 关于Go引入泛型的讨论</h1>
<p><a name="xTIBY"></a></p>
<h1 id="扩展阅读"><a class="markdownIt-Anchor" href="#扩展阅读"></a> 扩展阅读</h1>
<p><a name="JUiS0"></a></p>
<h2 id="go-map实现"><a class="markdownIt-Anchor" href="#go-map实现"></a> Go map实现</h2>
<p>为什么要在泛型里提到Go map的实现呢，大家都知道Go map是可以接收不同类型的kv的，那在没有泛型的时候它是怎么实现的？（其实是懒得再起一篇了，就顺便简单介绍一下<br /><strong>Go运行时是否使用interface{}？</strong><br />不，Go 运行时不用于interface{}实现其map。虽然我们有container/{list,heap}使用空接口的包，但运行时的map实现不使用interface{}.<br /><strong>编译器是否使用代码生成？</strong><br />不，Go 二进制文件中只有一份map实现的副本。只有一种实现，并且与 Java 不同，它不使用interface{}装箱。那么它是怎样工作的？<br />答案有两个部分，它们都涉及编译器和运行时之间的合作。<br />
<a name="ldHxh"></a></p>
<h3 id="编译时重写"><a class="markdownIt-Anchor" href="#编译时重写"></a> 编译时重写</h3>
<p>在编译期间，map操作被重写为对运行时的调用。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v := m[<span class="string">&quot;key&quot;</span>] 	  <span class="comment">// runtime.mapaccess1(m, ”key&quot;, &amp;v)</span></span><br><span class="line">v, ok := m[<span class="string">&quot;key&quot;</span>] <span class="comment">// runtime.mapaccess2(m, ”key”, &amp;v, &amp;ok)</span></span><br><span class="line">m[<span class="string">&quot;key&quot;</span>] = <span class="number">9001</span>   <span class="comment">// runtime.mapinsert(m, ”key&quot;, 9001)</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">&quot;key&quot;</span>)  <span class="comment">// runtime.mapdelete(m, “key”)</span></span><br></pre></td></tr></table></figure>
<p>类似的实现还有chan，但是slice不是。<br />
<a name="P1g14"></a></p>
<h3 id="运行时调用"><a class="markdownIt-Anchor" href="#运行时调用"></a> 运行时调用</h3>
<p>说了编译期间，再来看看运行时不使用interface又是如何解析具体类型的。</p>
<blockquote>
<p>源码面前，了无秘密</p>
</blockquote>
<p>我们直接来看一下函数签名<code>runtime.mapaccess1</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccess1</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们看一下这些参数。</p>
<ul>
<li>key是一个指向键的指针。</li>
<li>h是一个指向runtime.hmap结构体的指针。hmap是运行时的hash结构，用于保存存储桶和其他hash信息</li>
<li>t是一个指向runtime.maptype结构的指针</li>
</ul>
<p>那么可以猜到，<em>maptype就是使</em>hmap适用于（几乎）键和值类型的任何组合的原因。maptype中每个唯一的映射声明都有一个值。将会有一个描述从strings到ints、从strings到http.Headers等的映射。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> maptype <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ    _type</span><br><span class="line">	key    *_type</span><br><span class="line">	elem   *_type</span><br><span class="line">	bucket *_type <span class="comment">// internal type representing a hash bucket</span></span><br><span class="line">	<span class="comment">// function for hashing keys (ptr to key, seed) -&gt; hash</span></span><br><span class="line">	hasher     <span class="function"><span class="keyword">func</span><span class="params">(unsafe.Pointer, <span class="type">uintptr</span>)</span></span> <span class="type">uintptr</span></span><br><span class="line">	keysize    <span class="type">uint8</span>  <span class="comment">// size of key slot</span></span><br><span class="line">	elemsize   <span class="type">uint8</span>  <span class="comment">// size of elem slot</span></span><br><span class="line">	bucketsize <span class="type">uint16</span> <span class="comment">// size of bucket</span></span><br><span class="line">	flags      <span class="type">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个maptype都包含有关从key到elem的此类映射的属性的详细信息。它包含有关key和elem的信息。maptype.key包含有关我们传递的key的指针的信息。我们称这些为<strong>类型描述符</strong>。<br />到此为止，大概可以理解，为什么map可以处理几乎任意类型了，那就先点到为止，等下次写map分析时再具体展开说说吧。<br />
<a name="pZmFJ"></a></p>
<h1 id="结语"><a class="markdownIt-Anchor" href="#结语"></a> 结语</h1>
<blockquote>
<p>了解泛型的原理不一定会让你成为更好的开发人员，但它肯定会加深你对编程语言的理解。</p>
</blockquote>
<p>在编写参数多态代码时，Go 泛型是一个很好的补充。但通过了解泛型的具体实现，我们应该注意到，将接口作为类型参数传递给泛型函数会增加解析具体类型所需的查找次数，从而对性能产生不利影响。泛型的一个更好的用例是直接编写通用数据结构。消除了对接口类型的需求，并为许多优化打开了大门。<br />在泛型的实现中顺带提了一下map的多态实现，如果后面有时间再写一篇完整的map源码分析<br />
<a name="devUA"></a></p>
<h1 id="引用或延伸阅读"><a class="markdownIt-Anchor" href="#引用或延伸阅读"></a> 引用或延伸阅读</h1>
<p><a target="_blank" rel="noopener" href="https://github.com/golang/proposal/blob/master/design/generics-implementation-dictionaries-go1.18.md">https://github.com/golang/proposal/blob/master/design/generics-implementation-dictionaries-go1.18.md</a><br /><a target="_blank" rel="noopener" href="https://go.dev/ref/spec#Type_constraints">https://go.dev/ref/spec#Type_constraints</a><br /><a target="_blank" rel="noopener" href="https://go.dev/ref/spec#Comparison_operators">https://go.dev/ref/spec#Comparison_operators</a><br /><a target="_blank" rel="noopener" href="https://go.dev/blog/when-generics">https://go.dev/blog/when-generics</a><br /><a target="_blank" rel="noopener" href="https://go.dev/doc/tutorial/generics">https://go.dev/doc/tutorial/generics</a><br /><a target="_blank" rel="noopener" href="https://www.bmpi.dev/dev/deep-in-program-language/how-to-implement-generics/">https://www.bmpi.dev/dev/deep-in-program-language/how-to-implement-generics/</a><br /><a target="_blank" rel="noopener" href="https://deepsource.com/blog/go-1-18-generics-implementation">https://deepsource.com/blog/go-1-18-generics-implementation</a><br /><a target="_blank" rel="noopener" href="https://taoshu.in/go/generics/design.html#%E5%A4%8D%E5%90%88%E7%BA%A6%E6%9D%9F">https://taoshu.in/go/generics/design.html#%E5%A4%8D%E5%90%88%E7%BA%A6%E6%9D%9F</a><br /><a target="_blank" rel="noopener" href="https://medium.com/geekculture/go-generics-stories-behind-scenes-e520a43903">https://medium.com/geekculture/go-generics-stories-behind-scenes-e520a43903</a><br /><a target="_blank" rel="noopener" href="https://thume.ca/2019/07/14/a-tour-of-metaprogramming-models-for-generics/">https://thume.ca/2019/07/14/a-tour-of-metaprogramming-models-for-generics/</a><br /><a target="_blank" rel="noopener" href="https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics">https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics</a><br /><a target="_blank" rel="noopener" href="https://github.com/golang/proposal/blob/master/design/generics-implementation-dictionaries-go1.18.md">https://github.com/golang/proposal/blob/master/design/generics-implementation-dictionaries-go1.18.md</a><br /><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/xprmcl5qbf6yvdroajyn">https://www.infoq.cn/article/xprmcl5qbf6yvdroajyn</a><br /><a target="_blank" rel="noopener" href="https://go.dev/ref/spec">https://go.dev/ref/spec</a><br /><a target="_blank" rel="noopener" href="https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md">https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md</a><br />一个泛型库：<a target="_blank" rel="noopener" href="https://github.com/samber/lo">https://github.com/samber/lo</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Fish</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2023/06/12/2023-06-12-Go与泛型/">http://example.com/2023/06/12/2023-06-12-Go与泛型/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2023/08/12/2022-06-17-%E4%BD%BF%E7%94%A8GoLand%E8%B0%83%E8%AF%95%E7%BC%96%E8%AF%91/"><i class="fa fa-chevron-left">  </i><span></span></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2023 By Fish</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>