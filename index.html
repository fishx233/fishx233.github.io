<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords" content=""><meta name="author" content="Fish"><meta name="copyright" content="Fish"><title>Fish</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.3.0'
} </script><meta name="generator" content="Hexo 6.3.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Fish</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">7</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Fish</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right"></span></div><div id="site-info"><div id="site-title">Fish</div><div id="site-sub-title"></div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2023/08/12/2023-03-09-visual-chatgpt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">No title</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-08-12</time><div class="content"><h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1>
<p>使用chatgpt连接一系列模型，支持聊天期间发送和接收图像。<br />
从实际代码上看就是LLM+工具箱，简称缝合怪。<br />
代码基于早期版本，可能现在有所不同。</p>
<h1 id="效果"><a class="markdownIt-Anchor" href="#效果"></a> 效果</h1>
<p>反手就去github上偷一张效果图。<br />
<img src="https://cdn.nlark.com/yuque/0/2023/png/1487474/1691812437359-fb4f8c78-49a8-4eb7-bcb2-e4c85c934998.png#averageHue=%23af9a84&amp;clientId=u724c9408-4af4-4&amp;from=paste&amp;id=u640c1b8a&amp;originHeight=1186&amp;originWidth=1504&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=udad6b98f-8820-4d88-af50-6a7dc865874&amp;title=" alt="" /></p>
<h1 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h1>
<p><strong>硬编码的咒语</strong><br />
先看一段硬编码的chatGPT的对话，看这一段内容，其实就可以把实现猜个八九不离十了，这段内容对LLM设定了一系列规则，并引导他使用工具列表来帮助他完成视觉能力。<br />
变量说明：<br />
tool_names：工具列表，[<a target="_blank" rel="noopener" href="http://tool.name">tool.name</a>, <a target="_blank" rel="noopener" href="http://tool.name">tool.name</a>]<br />
ai_prefix：ai的对话前缀，默认填充AI。<br />
chat_history：这里会填充对话历史<br />
input：这个是最新的输入<br />
agent_scratchpad：会暂存工具使用的中间对话</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">VISUAL_CHATGPT_PREFIX = <span class="string">&quot;&quot;&quot;Visual ChatGPT is designed to be able to assist with a wide range of text and visual related tasks, from answering simple questions to providing in-depth explanations and discussions on a wide range of topics. Visual ChatGPT is able to generate human-like text based on the input it receives, allowing it to engage in natural-sounding conversations and provide responses that are coherent and relevant to the topic at hand.</span></span><br><span class="line"><span class="string">Visual ChatGPT is able to process and understand large amounts of text and images. As a language model, Visual ChatGPT can not directly read images, but it has a list of tools to finish different visual tasks. Each image will have a file name formed as &quot;image/xxx.png&quot;, and Visual ChatGPT can invoke different tools to indirectly understand pictures. When talking about images, Visual ChatGPT is very strict to the file name and will never fabricate nonexistent files. When using tools to generate new image files, Visual ChatGPT is also known that the image may not be the same as the user&#x27;s demand, and will use other visual question answering tools or description tools to observe the real image. Visual ChatGPT is able to use tools in a sequence, and is loyal to the tool observation outputs rather than faking the image content and image file name. It will remember to provide the file name from the last tool observation, if a new image is generated.</span></span><br><span class="line"><span class="string">Human may provide new figures to Visual ChatGPT with a description. The description helps Visual ChatGPT to understand this image, but Visual ChatGPT should use tools to finish following tasks, rather than directly imagine from the description.</span></span><br><span class="line"><span class="string">Overall, Visual ChatGPT is a powerful visual dialogue assistant tool that can help with a wide range of tasks and provide valuable insights and information on a wide range of topics. </span></span><br><span class="line"><span class="string">TOOLS:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Visual ChatGPT  has access to the following tools:&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">VISUAL_CHATGPT_FORMAT_INSTRUCTIONS = <span class="string">&quot;&quot;&quot;To use a tool, please use the following format:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Thought: Do I need to use a tool? Yes</span></span><br><span class="line"><span class="string">Action: the action to take, should be one of [&#123;tool_names&#125;]</span></span><br><span class="line"><span class="string">Action Input: the input to the action</span></span><br><span class="line"><span class="string">Observation: the result of the action</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">When you have a response to say to the Human, or if you do not need to use a tool, you MUST use the format:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Thought: Do I need to use a tool? No</span></span><br><span class="line"><span class="string">&#123;ai_prefix&#125;: [your response here]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">VISUAL_CHATGPT_SUFFIX = <span class="string">&quot;&quot;&quot;You are very strict to the filename correctness and will never fake a file name if it does not exist.</span></span><br><span class="line"><span class="string">You will remember to provide the image file name loyally if it&#x27;s provided in the last tool observation.</span></span><br><span class="line"><span class="string">Begin!</span></span><br><span class="line"><span class="string">Previous conversation history:</span></span><br><span class="line"><span class="string">&#123;chat_history&#125;</span></span><br><span class="line"><span class="string">New input: &#123;input&#125;</span></span><br><span class="line"><span class="string">Since Visual ChatGPT is a text language model, Visual ChatGPT must use tools to observe images rather than imagination.</span></span><br><span class="line"><span class="string">The thoughts and observations are only visible for Visual ChatGPT, Visual ChatGPT should remember to repeat important information in the final response for Human. </span></span><br><span class="line"><span class="string">Thought: Do I need to use a tool? &#123;agent_scratchpad&#125;&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>最终拼接的模版大致如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;prefix&#125;  <span class="comment"># 上一个代码块的VISUAL_CHATGPT_PREFIX内容</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># 工具列表内容，长这样 </span></span><br><span class="line"><span class="string">tool.name: tool.description</span></span><br><span class="line"><span class="string">tool.name: tool.description</span></span><br><span class="line"><span class="string">tool.name: tool.description</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">&#123;tool_strings&#125; </span><br><span class="line"></span><br><span class="line">&#123;format_instructions&#125; <span class="comment"># 上一个代码块的VISUAL_CHATGPT_FORMAT_INSTRUCTIONS内容</span></span><br><span class="line"></span><br><span class="line">&#123;suffix&#125; <span class="comment"># 上一个代码块的VISUAL_CHATGPT_SUFFIX内容</span></span><br></pre></td></tr></table></figure>
<p><strong>发送文本</strong><br />
文本内容就比较简单直接发送对话</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">run_text</span>(<span class="params">self, text, state</span>):</span><br><span class="line">    self.agent.memory.buffer = cut_dialogue_history(self.agent.memory.buffer, keep_last_n_words=<span class="number">500</span>)</span><br><span class="line">    res = self.agent(&#123;<span class="string">&quot;input&quot;</span>: text&#125;)</span><br><span class="line">    res[<span class="string">&#x27;output&#x27;</span>] = res[<span class="string">&#x27;output&#x27;</span>].replace(<span class="string">&quot;\\&quot;</span>, <span class="string">&quot;/&quot;</span>)</span><br><span class="line">    response = re.sub(<span class="string">&#x27;(image/\S*png)&#x27;</span>, <span class="keyword">lambda</span> m: <span class="string">f&#x27;![](/file=<span class="subst">&#123;m.group(<span class="number">0</span>)&#125;</span>)*<span class="subst">&#123;m.group(<span class="number">0</span>)&#125;</span>*&#x27;</span>, res[<span class="string">&#x27;output&#x27;</span>])</span><br><span class="line">    state = state + [(text, response)]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\nProcessed run_text, Input text: <span class="subst">&#123;text&#125;</span>\nCurrent state: <span class="subst">&#123;state&#125;</span>\n&quot;</span></span><br><span class="line">          <span class="string">f&quot;Current Memory: <span class="subst">&#123;self.agent.memory.buffer&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> state, state</span><br></pre></td></tr></table></figure>
<p><strong>发送图片</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">run_image</span>(<span class="params">self, image, state, txt</span>):</span><br><span class="line">    image_filename = os.path.join(<span class="string">&#x27;image&#x27;</span>, <span class="built_in">str</span>(uuid.uuid4())[<span class="number">0</span>:<span class="number">8</span>] + <span class="string">&quot;.png&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;======&gt;Auto Resize Image...&quot;</span>)</span><br><span class="line">    img = Image.<span class="built_in">open</span>(image.name)</span><br><span class="line">    width, height = img.size</span><br><span class="line">    ratio = <span class="built_in">min</span>(<span class="number">512</span> / width, <span class="number">512</span> / height)</span><br><span class="line">    width_new, height_new = (<span class="built_in">round</span>(width * ratio), <span class="built_in">round</span>(height * ratio))</span><br><span class="line">    width_new = <span class="built_in">int</span>(np.<span class="built_in">round</span>(width_new / <span class="number">64.0</span>)) * <span class="number">64</span></span><br><span class="line">    height_new = <span class="built_in">int</span>(np.<span class="built_in">round</span>(height_new / <span class="number">64.0</span>)) * <span class="number">64</span></span><br><span class="line">    img = img.resize((width_new, height_new))</span><br><span class="line">    img = img.convert(<span class="string">&#x27;RGB&#x27;</span>)</span><br><span class="line">    img.save(image_filename, <span class="string">&quot;PNG&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Resize image form <span class="subst">&#123;width&#125;</span>x<span class="subst">&#123;height&#125;</span> to <span class="subst">&#123;width_new&#125;</span>x<span class="subst">&#123;height_new&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># 这个模型用的是Salesforce/blip-image-captioning-base，从图片生成标题，生成结果会当作图片描述</span></span><br><span class="line">    <span class="comment"># 然后又有一段硬编码对话，继续引导ai使用工具来理解图片</span></span><br><span class="line">    description = self.models[<span class="string">&#x27;ImageCaptioning&#x27;</span>].inference(image_filename)</span><br><span class="line">    Human_prompt = <span class="string">&quot;\nHuman: provide a figure named &#123;&#125;. The description is: &#123;&#125;. &quot;</span> \</span><br><span class="line">    <span class="string">&quot;This information helps you to understand this image, &quot;</span> \</span><br><span class="line">    <span class="string">&quot;but you should use tools to finish following tasks, &quot;</span> \</span><br><span class="line">    <span class="string">&quot;rather than directly imagine from my description. If you understand, say \&quot;Received\&quot;. \n&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">        image_filename, description)</span><br><span class="line">    <span class="comment"># 帮ai回答 收到！</span></span><br><span class="line">    AI_prompt = <span class="string">&quot;Received.  &quot;</span></span><br><span class="line">    self.agent.memory.buffer = self.agent.memory.buffer + Human_prompt + <span class="string">&#x27;AI: &#x27;</span> + AI_prompt</span><br><span class="line">    state = state + [(<span class="string">f&quot;![](/file=<span class="subst">&#123;image_filename&#125;</span>)*<span class="subst">&#123;image_filename&#125;</span>*&quot;</span>, AI_prompt)]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\nProcessed run_image, Input image: <span class="subst">&#123;image_filename&#125;</span>\nCurrent state: <span class="subst">&#123;state&#125;</span>\n&quot;</span></span><br><span class="line">          <span class="string">f&quot;Current Memory: <span class="subst">&#123;self.agent.memory.buffer&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> state, state, txt + <span class="string">&#x27; &#x27;</span> + image_filename + <span class="string">&#x27; &#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>工具</strong><br />
里面用的工具都是各种模型功能，比如text2img，发送给LLM的内容就是name+description，之后如何LLM期望使用这个工具，就会调用inference来返回结果。<br />
<img src="https://cdn.nlark.com/yuque/0/2023/png/1487474/1691812437310-26e656c8-dde2-429b-a283-d7a981f17655.png#averageHue=%23fefcfc&amp;clientId=u724c9408-4af4-4&amp;from=paste&amp;id=uc14525b7&amp;originHeight=1024&amp;originWidth=2268&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc1664fc4-fe09-4d33-ba8c-7d7e2a68b2c&amp;title=" alt="" /><br />
<strong>可供使用的工具有如下（比刚看开始又多了）</strong></p>
<table>
<thead>
<tr>
<th><strong>Foundation Model</strong></th>
<th><strong>GPU Memory (MB)</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>ImageEditing</td>
<td>3981</td>
</tr>
<tr>
<td>InstructPix2Pix</td>
<td>2827</td>
</tr>
<tr>
<td>Text2Image</td>
<td>3385</td>
</tr>
<tr>
<td>ImageCaptioning</td>
<td>1209</td>
</tr>
<tr>
<td>Image2Canny</td>
<td>0</td>
</tr>
<tr>
<td>CannyText2Image</td>
<td>3531</td>
</tr>
<tr>
<td>Image2Line</td>
<td>0</td>
</tr>
<tr>
<td>LineText2Image</td>
<td>3529</td>
</tr>
<tr>
<td>Image2Hed</td>
<td>0</td>
</tr>
<tr>
<td>HedText2Image</td>
<td>3529</td>
</tr>
<tr>
<td>Image2Scribble</td>
<td>0</td>
</tr>
<tr>
<td>ScribbleText2Image</td>
<td>3531</td>
</tr>
<tr>
<td>Image2Pose</td>
<td>0</td>
</tr>
<tr>
<td>PoseText2Image</td>
<td>3529</td>
</tr>
<tr>
<td>Image2Seg</td>
<td>919</td>
</tr>
<tr>
<td>SegText2Image</td>
<td>3529</td>
</tr>
<tr>
<td>Image2Depth</td>
<td>0</td>
</tr>
<tr>
<td>DepthText2Image</td>
<td>3531</td>
</tr>
<tr>
<td>Image2Normal</td>
<td>0</td>
</tr>
<tr>
<td>NormalText2Image</td>
<td>3529</td>
</tr>
<tr>
<td>VisualQuestionAnswering</td>
<td>1495</td>
</tr>
</tbody>
</table>
<h1 id="扩展阅读"><a class="markdownIt-Anchor" href="#扩展阅读"></a> 扩展阅读</h1>
<h2 id="langchain"><a class="markdownIt-Anchor" href="#langchain"></a> langchain</h2>
<h3 id="简介-2"><a class="markdownIt-Anchor" href="#简介-2"></a> 简介</h3>
<p>LLM很强，但是单独使用这些 LLM 往往不足以创建一个真正强大的应用程序—当您将它们与其他工具结合时，真正的力量就来了。visual-chatgpt主要用到了langchain的**agents和memory（历史对话）**能力。</p>
<h3 id="agent"><a class="markdownIt-Anchor" href="#agent"></a> <strong>agent</strong></h3>
<p>因为主要用了这个功能，简单讲一下这块的代码<br />
核心调用入口在_call方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;Run text through and get agent response.&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># Do any preparation necessary when receiving a new input.</span></span><br><span class="line">self.agent.prepare_for_new_call()</span><br><span class="line"><span class="comment"># Construct a mapping of tool name to tool for easy lookup</span></span><br><span class="line">name_to_tool_map = &#123;tool.name: tool <span class="keyword">for</span> tool <span class="keyword">in</span> self.tools&#125;</span><br><span class="line"><span class="comment"># We construct a mapping from each tool to a color, used for logging.</span></span><br><span class="line">color_mapping = get_color_mapping(</span><br><span class="line">    [tool.name <span class="keyword">for</span> tool <span class="keyword">in</span> self.tools], excluded_colors=[<span class="string">&quot;green&quot;</span>]</span><br><span class="line">)</span><br><span class="line">intermediate_steps: <span class="type">List</span>[<span class="type">Tuple</span>[AgentAction, <span class="built_in">str</span>]] = []</span><br><span class="line"><span class="comment"># Let&#x27;s start tracking the iterations the agent has gone through</span></span><br><span class="line">iterations = <span class="number">0</span></span><br><span class="line"><span class="comment"># We now enter the agent loop (until it returns something).</span></span><br><span class="line"><span class="comment"># 进入循环，直到获取到结果，如果超出循环次数也会直接返回</span></span><br><span class="line"><span class="keyword">while</span> self._should_continue(iterations):</span><br><span class="line">    next_step_output = self._take_next_step(</span><br><span class="line">        name_to_tool_map, color_mapping, inputs, intermediate_steps</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 遇到中止识别，则返回最终结果，怎样算中止，可以看下一段代码</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(next_step_output, AgentFinish):</span><br><span class="line">        <span class="keyword">return</span> self._<span class="keyword">return</span>(next_step_output, intermediate_steps)</span><br><span class="line">    <span class="comment"># 否则会保存上一步的信息</span></span><br><span class="line">    intermediate_steps.append(next_step_output)</span><br><span class="line">    iterations += <span class="number">1</span></span><br><span class="line"><span class="comment"># 中止有特殊处理    </span></span><br><span class="line">output = self.agent.return_stopped_response(</span><br><span class="line">    self.early_stopping_method, intermediate_steps, **inputs</span><br><span class="line">)</span><br><span class="line"><span class="keyword">return</span> self._<span class="keyword">return</span>(output, intermediate_steps)</span><br></pre></td></tr></table></figure>
<p><strong>提取工具或是中止</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个类型的中止标记是获取到ai的输出，例如ai:xxx</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">finish_tool_name</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Name of the tool to use to finish the chain.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> self.ai_prefix</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_extract_tool_and_input</span>(<span class="params">self, llm_output: <span class="built_in">str</span></span>) -&gt; <span class="type">Optional</span>[<span class="type">Tuple</span>[<span class="built_in">str</span>, <span class="built_in">str</span>]]:</span><br><span class="line">    <span class="comment"># 如果获取到了ai的回答则中止</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">f&quot;<span class="subst">&#123;self.ai_prefix&#125;</span>:&quot;</span> <span class="keyword">in</span> llm_output:</span><br><span class="line">        <span class="keyword">return</span> self.ai_prefix, llm_output.split(<span class="string">f&quot;<span class="subst">&#123;self.ai_prefix&#125;</span>:&quot;</span>)[-<span class="number">1</span>].strip()</span><br><span class="line">    <span class="comment"># 否则提取应该使用的工具</span></span><br><span class="line">    regex = <span class="string">r&quot;Action: (.*?)[\n]*Action Input: (.*)&quot;</span></span><br><span class="line">    <span class="keyword">match</span> = re.search(regex, llm_output)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">match</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">f&quot;Could not parse LLM output: `<span class="subst">&#123;llm_output&#125;</span>`&quot;</span>)</span><br><span class="line">    action = <span class="keyword">match</span>.group(<span class="number">1</span>)</span><br><span class="line">    action_input = <span class="keyword">match</span>.group(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> action.strip(), action_input.strip(<span class="string">&quot; &quot;</span>).strip(<span class="string">&#x27;&quot;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>顺便再贴一下默认的咒语</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">PREFIX = <span class="string">&quot;&quot;&quot;Assistant is a large language model trained by OpenAI.</span></span><br><span class="line"><span class="string">Assistant is designed to be able to assist with a wide range of tasks, from answering simple questions to providing in-depth explanations and discussions on a wide range of topics. As a language model, Assistant is able to generate human-like text based on the input it receives, allowing it to engage in natural-sounding conversations and provide responses that are coherent and relevant to the topic at hand.</span></span><br><span class="line"><span class="string">Assistant is constantly learning and improving, and its capabilities are constantly evolving. It is able to process and understand large amounts of text, and can use this knowledge to provide accurate and informative responses to a wide range of questions. Additionally, Assistant is able to generate its own text based on the input it receives, allowing it to engage in discussions and provide explanations and descriptions on a wide range of topics.</span></span><br><span class="line"><span class="string">Overall, Assistant is a powerful tool that can help with a wide range of tasks and provide valuable insights and information on a wide range of topics. Whether you need help with a specific question or just want to have a conversation about a particular topic, Assistant is here to assist.</span></span><br><span class="line"><span class="string">TOOLS:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Assistant has access to the following tools:&quot;&quot;&quot;</span></span><br><span class="line">FORMAT_INSTRUCTIONS = <span class="string">&quot;&quot;&quot;To use a tool, please use the following format:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Thought: Do I need to use a tool? Yes</span></span><br><span class="line"><span class="string">Action: the action to take, should be one of [&#123;tool_names&#125;]</span></span><br><span class="line"><span class="string">Action Input: the input to the action</span></span><br><span class="line"><span class="string">Observation: the result of the action</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">When you have a response to say to the Human, or if you do not need to use a tool, you MUST use the format:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Thought: Do I need to use a tool? No</span></span><br><span class="line"><span class="string">&#123;ai_prefix&#125;: [your response here]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">SUFFIX = <span class="string">&quot;&quot;&quot;Begin!</span></span><br><span class="line"><span class="string">Previous conversation history:</span></span><br><span class="line"><span class="string">&#123;chat_history&#125;</span></span><br><span class="line"><span class="string">New input: &#123;input&#125;</span></span><br><span class="line"><span class="string">&#123;agent_scratchpad&#125;&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="tools"><a class="markdownIt-Anchor" href="#tools"></a> tools</h3>
<p>langchain已经自带的工具列表，包括计算器，python shell，天气查询api，搜索api等<br />
详细见：<a target="_blank" rel="noopener" href="https://langchain.readthedocs.io/en/latest/modules/agents/tools.html">https://langchain.readthedocs.io/en/latest/modules/agents/tools.html</a></p>
<h2 id="llama_index"><a class="markdownIt-Anchor" href="#llama_index"></a> llama_index</h2>
<p><strong>咒语</strong><br />
<img src="https://cdn.nlark.com/yuque/0/2023/png/1487474/1691812437241-c15d8c5f-b9ad-4078-bf8e-fa9763b8a10c.png#averageHue=%232b2b2b&amp;clientId=u724c9408-4af4-4&amp;from=paste&amp;id=u2582622d&amp;originHeight=376&amp;originWidth=1170&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ucbd44645-1922-4109-9d20-52f7db347d2&amp;title=" alt="" /></p>
<h1 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h1>
<p>:::info<br />
✍️让LLM学会使用工具！<br />
:::<br />
这种形式看上去可以延伸出很多骚操作，例如当前LLM无法获取最新的时事信息，或是网页信息，只要结合工具，帮他去获取信息从而给他分析，new bing就通过将搜索结果结合GPT4来分析；再比如visual-chatgpt通过结合各种图像模型，让LLM获取视觉能力。</p>
<h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1>
<p><a target="_blank" rel="noopener" href="https://github.com/microsoft/visual-chatgpt">https://github.com/microsoft/visual-chatgpt</a><br />
<a target="_blank" rel="noopener" href="https://github.com/hwchase17/langchain">https://github.com/hwchase17/langchain</a><br />
<a target="_blank" rel="noopener" href="https://github.com/jerryjliu/llama_index">https://github.com/jerryjliu/llama_index</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/08/12/2021-10-09-Go%20database%20%E8%BF%9E%E6%8E%A5%E6%B1%A0%20%E8%BF%9E%E6%8E%A5%E6%A3%80%E6%9F%A5%E5%92%8C%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6/">No title</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-08-12</time><div class="content"><p><a name="eReVB"></a></p>
<h2 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论</h2>
<p>Go mysql driver中在使用前会对从连接池中获取的连接进行生存检查（可配置，默认开启），并且database中会有对应的重试机制，当连接池中没有连接时，会创建新的连接。<br />
<a name="bCdJ0"></a></p>
<h2 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h2>
<ol>
<li>设置连接池空闲和活跃连接数DBMaxIdle, DBMaxOpen，最大连接数可达DBMaxIdle+DBMaxOpen，根据pod合理设置，在pod过多的情况下，会导致连接数过多。推荐配置：2*cpu-1</li>
<li>设置连接超时时间timeout。<br />
<a name="sQ2b1"></a></li>
</ol>
<h2 id="源码分析"><a class="markdownIt-Anchor" href="#源码分析"></a> 源码分析</h2>
<ol>
<li>在执行操作时（如图Query，Exec等类型类似）, 若err为ErrBadConn会有一定次数的重试机制，若超过一定次数（2次），会选择直接创建新的连接，不从连接池获取。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/1487474/1691818089157-0d0e0a7d-3c43-446f-ad24-288f01bc45cb.png#averageHue=%232d2c2c&amp;clientId=ud09f463a-4ced-4&amp;from=paste&amp;id=u4c5edbcf&amp;originHeight=356&amp;originWidth=1052&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8b4dfc81-84e4-4c4c-aaf3-e334eda0892&amp;title=" alt="" /></p>
<ol>
<li>重试次数，常量值，固定为2。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/1487474/1691818089204-e73ff3d2-f766-4a5d-92a3-c64f134aeca8.png#averageHue=%23303030&amp;clientId=ud09f463a-4ced-4&amp;from=paste&amp;id=u279bcb52&amp;originHeight=110&amp;originWidth=699&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2300a13c-c6c4-4cbb-aa5b-87ea31458b9&amp;title=" alt="" /></p>
<ol>
<li>Conn优先从空闲连接中获取一个，如果空闲区中没有可用连接，将创建一个新的连接（根据设置的MaxOpen数，达到上限会等待）</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/1487474/1691818089129-02d1d313-0658-4529-8417-9991bb146af6.png#averageHue=%232f2c2c&amp;clientId=ud09f463a-4ced-4&amp;from=paste&amp;id=u48e755df&amp;originHeight=1116&amp;originWidth=1057&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u3ac2606d-53a4-40c9-bb6a-36314d762b1&amp;title=" alt="" /></p>
<ol>
<li>使用前对连接进行生存检查，默认为true。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/1487474/1691818089156-a3c057f1-76e4-46fd-ab72-d928a040fa32.png#averageHue=%232d2c2c&amp;clientId=ud09f463a-4ced-4&amp;from=paste&amp;id=u55dfd6c3&amp;originHeight=230&amp;originWidth=611&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u327beca4-8674-401a-9bab-2a281196557&amp;title=" alt="" /></p>
<ol>
<li>在数据写入缓存区前，如果设置了checkConnLiveness，会对从<strong>连接池中</strong>取出的连接进行生存检查。检查失败，会抛出ErrBadConn，可供上层重试处理，见 #1</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/1487474/1691818089136-24e28145-1e0f-4ed3-b3e9-444c8e05df3e.png#averageHue=%232f2d2d&amp;clientId=ud09f463a-4ced-4&amp;from=paste&amp;id=u33e70450&amp;originHeight=623&amp;originWidth=858&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ue48e55d5-55a5-490f-9bff-e04b93c0b8d&amp;title=" alt="" /><br />
<a name="UKbac"></a></p>
<h2 id="相关代码"><a class="markdownIt-Anchor" href="#相关代码"></a> 相关代码</h2>
<p>database/sql <br />go-sql-driver/mysql</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/08/12/2023-02-22-Kratos%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">No title</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-08-12</time><div class="content"><p><a name="QWhhm"></a></p>
<h1 id="准备"><a class="markdownIt-Anchor" href="#准备"></a> 准备</h1>
<ul>
<li>代码基于v2.5.4<br />
<a name="sx6oE"></a></li>
</ul>
<h1 id="目录结构"><a class="markdownIt-Anchor" href="#目录结构"></a> 目录结构</h1>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── api # api目前，存放api proto文件，目前主要放传输的metadata proto定义</span><br><span class="line">├── cmd # 工具组件，主要包含kratos, protoc-gen-go-errors, protoc-gen-go-http等命令工具，代码生成</span><br><span class="line">├── config # 配置组件，包含Config组件的接口定义和基本的env和file config实现</span><br><span class="line">├── contrib # 三方组件，包含kratos支持的三方组件实现，包含服务注册服务发现组件(etcd, zk等)，配置组件(apollo，nacos等)等等</span><br><span class="line">│   ├── config # 三方配置组件</span><br><span class="line">│   ├── encoding # 三方序列化组件 </span><br><span class="line">│   ├── log # 三方日志组件</span><br><span class="line">│   ├── metrics # 三方指标组件</span><br><span class="line">│   ├── opensergo # OpenSergo</span><br><span class="line">│   ├── polaris # 北极星</span><br><span class="line">│   └── registry # 三方服务注册服务组件</span><br><span class="line">├── docs # 文档</span><br><span class="line">├── encoding # 序列化组件，包含基本的form，json，proto，yaml，xml的解析</span><br><span class="line">├── errors # 自定义error实现</span><br><span class="line">├── internal # 内部实现方法</span><br><span class="line">├── log # 日志组件接口定义，基本操作如敏感词过滤，高级日志助手的封装</span><br><span class="line">├── metadata # metadata元数据操作方法</span><br><span class="line">├── metrics # 指标组件接口定义</span><br><span class="line">├── middleware # 中间件</span><br><span class="line">├── registry # 服务注册发现组件接口定义</span><br><span class="line">├── selector # 路由和负载均衡的接口定义和内置实现</span><br><span class="line">├── third_party # 三方包，例如三方的proto文件</span><br><span class="line">└── transport # 协议实现，目前支持http和grpc</span><br></pre></td></tr></table></figure>
<p><a name="ipMmN"></a></p>
<h1 id="启动服务"><a class="markdownIt-Anchor" href="#启动服务"></a> 启动服务</h1>
<p><a name="a1VnJ"></a></p>
<h2 id="流程"><a class="markdownIt-Anchor" href="#流程"></a> 流程</h2>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/1487474/1691816746471-d407ff6a-c917-4b0b-a938-be6daf467eae.png#averageHue=%231c1b18&amp;clientId=u59b681d6-7a1d-4&amp;from=paste&amp;id=u08d3718c&amp;originHeight=1122&amp;originWidth=878&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u868a05c9-e431-4aeb-893f-ba3195e47e9&amp;title=" alt="" /><br /><strong>ps：偷的图</strong><br />
<a name="bTHQN"></a></p>
<h2 id="代码分析"><a class="markdownIt-Anchor" href="#代码分析"></a> 代码分析</h2>
<p><strong>初始化</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个核心的kratos app，管理服务server的生命周期，可以配置Server Start,Stop生命周期对应的拦截器；实例的基本信息</span></span><br><span class="line">App := kratos.New(</span><br><span class="line">    kratos.ID(id),</span><br><span class="line">    kratos.Name(Name),</span><br><span class="line">    kratos.Version(Version),</span><br><span class="line">    kratos.Metadata(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;&#125;),</span><br><span class="line">    kratos.Logger(logger),</span><br><span class="line">    kratos.Server(</span><br><span class="line">        hs,</span><br><span class="line">    ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><strong>启动</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// run之后就会把对应的服务启用起来，监听对应端口，run是一个阻塞的方法</span></span><br><span class="line">App.Run()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *App)</span></span> Run() <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 创建服务注册实例，包含server的一些元数据信息，主要在服务注册发现中使用，端点，版本号，id，version啥的</span></span><br><span class="line">    instance, err := a.buildInstance()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    a.mu.Lock()</span><br><span class="line">    a.instance = instance</span><br><span class="line">    a.mu.Unlock()</span><br><span class="line">    sctx := NewContext(a.ctx, a)</span><br><span class="line">    <span class="comment">// 使用errgroup来启动所有server</span></span><br><span class="line">    eg, ctx := errgroup.WithContext(sctx)</span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    <span class="comment">// 执行拦截器</span></span><br><span class="line">    <span class="keyword">for</span> _, fn := <span class="keyword">range</span> a.opts.beforeStart &#123;</span><br><span class="line">        <span class="keyword">if</span> err = fn(sctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启用所有server</span></span><br><span class="line">    <span class="keyword">for</span> _, srv := <span class="keyword">range</span> a.opts.servers &#123;</span><br><span class="line">        srv := srv</span><br><span class="line">        eg.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">            &lt;-ctx.Done() <span class="comment">// wait for stop signal</span></span><br><span class="line">            stopCtx, cancel := context.WithTimeout(NewContext(a.opts.ctx, a), a.opts.stopTimeout)</span><br><span class="line">            <span class="keyword">defer</span> cancel()</span><br><span class="line">            <span class="keyword">return</span> srv.Stop(stopCtx)</span><br><span class="line">        &#125;)</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        eg.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">            wg.Done() <span class="comment">// here is to ensure server start has begun running before register, so defer is not needed</span></span><br><span class="line">            <span class="keyword">return</span> srv.Start(sctx)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="keyword">if</span> a.opts.registrar != <span class="literal">nil</span> &#123;</span><br><span class="line">        rctx, rcancel := context.WithTimeout(ctx, a.opts.registrarTimeout)</span><br><span class="line">        <span class="keyword">defer</span> rcancel()</span><br><span class="line">        <span class="keyword">if</span> err = a.opts.registrar.Register(rctx, instance); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, fn := <span class="keyword">range</span> a.opts.afterStart &#123;</span><br><span class="line">        <span class="keyword">if</span> err = fn(sctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 监听推出信号，监听的信号在NewApp的时候可以配置</span></span><br><span class="line">    signal.Notify(c, a.opts.sigs...)</span><br><span class="line">    eg.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            <span class="keyword">case</span> &lt;-c:</span><br><span class="line">            <span class="keyword">return</span> a.Stop()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 等着咯，服务已经run起来了</span></span><br><span class="line">    <span class="keyword">if</span> err = eg.Wait(); err != <span class="literal">nil</span> &amp;&amp; !errors.Is(err, context.Canceled) &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, fn := <span class="keyword">range</span> a.opts.afterStop &#123;</span><br><span class="line">        err = fn(sctx)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="i4ndz"></a></p>
<h1 id="中间件"><a class="markdownIt-Anchor" href="#中间件"></a> 中间件</h1>
<p>在http代码中使用时，这段是使用protoc-gen-go-http生成的代码，kratos在生成的代码中塞入了中间件的执行逻辑</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handler defines the handler invoked by Middleware.</span></span><br><span class="line"><span class="keyword">type</span> Handler <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Middleware is HTTP/gRPC transport middleware.</span></span><br><span class="line"><span class="keyword">type</span> Middleware <span class="function"><span class="keyword">func</span><span class="params">(Handler)</span></span> Handler</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过这个方法组装所有的中间件Handler，并返回一个新的中间件，所有中件间将按顺序链式执行</span></span><br><span class="line"><span class="comment">// Chain returns a Middleware that specifies the chained handler for endpoint.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Chain</span><span class="params">(m ...Middleware)</span></span> Middleware &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(next Handler)</span></span> Handler &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="built_in">len</span>(m) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">            next = m[i](next)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在grpc代码中使用时，kratos会在grpc的第一个拦截器中放入中间件的执行代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> _<span class="title">Helloworld_Helloworld0_HTTP_Handler</span><span class="params">(srv HelloworldHTTPServer)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(ctx http.Context)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx http.Context)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> in HelloworldRequest</span><br><span class="line">        <span class="keyword">if</span> err := ctx.BindQuery(&amp;in); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err := ctx.BindVars(&amp;in); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        http.SetOperation(ctx, <span class="string">&quot;/api.helloworld.service.v1.Helloworld/Helloworld&quot;</span>)</span><br><span class="line">        <span class="comment">// 生成整个执行的中间件链路Handler，最后的service方法将会放进中间件的最后一个执行</span></span><br><span class="line">        h := ctx.Middleware(<span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> srv.Helloworld(ctx, req.(*HelloworldRequest))</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 开始执行所有中件间</span></span><br><span class="line">        out, err := h(ctx, &amp;in)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        reply := out.(*HelloworldReply)</span><br><span class="line">        <span class="keyword">return</span> ctx.Result(<span class="number">200</span>, reply)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ctx.Middleware func</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *wrapper)</span></span> Middleware(h middleware.Handler) middleware.Handler &#123;</span><br><span class="line">    <span class="keyword">return</span> middleware.Chain(c.router.srv.ms...)(h)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// grpc/server.go NewServer</span></span><br><span class="line"><span class="comment">// ...省略</span></span><br><span class="line"><span class="comment">// kratos定义的第一个拦截器，中间件的执行在这里面</span></span><br><span class="line">unaryInts := []grpc.UnaryServerInterceptor&#123;</span><br><span class="line">    srv.unaryServerInterceptor(),</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 流式拦截器</span></span><br><span class="line">streamInts := []grpc.StreamServerInterceptor&#123;</span><br><span class="line">    srv.streamServerInterceptor(),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(srv.unaryInts) &gt; <span class="number">0</span> &#123;</span><br><span class="line">    unaryInts = <span class="built_in">append</span>(unaryInts, srv.unaryInts...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(srv.streamInts) &gt; <span class="number">0</span> &#123;</span><br><span class="line">    streamInts = <span class="built_in">append</span>(streamInts, srv.streamInts...)</span><br><span class="line">&#125;</span><br><span class="line">grpcOpts := []grpc.ServerOption&#123;</span><br><span class="line">    grpc.ChainUnaryInterceptor(unaryInts...),</span><br><span class="line">    grpc.ChainStreamInterceptor(streamInts...),</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unaryServerInterceptor is a gRPC unary server interceptor</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span></span> unaryServerInterceptor() grpc.UnaryServerInterceptor &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">        <span class="comment">// ...省略代码</span></span><br><span class="line">        h := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> handler(ctx, req)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意这部分</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s.middleware) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            h = middleware.Chain(s.middleware...)(h)</span><br><span class="line">        &#125;</span><br><span class="line">        reply, err := h(ctx, req)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(replyHeader) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            _ = grpc.SetHeader(ctx, replyHeader)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reply, err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上都是服务端的实现，客户端也是类似的实现，通过抽象一个中间件来实现对grpc和http统一处理，只要一套中间件逻辑就能同时用在两个甚至多个不同协议中。<br />
<a name="WDZgj"></a></p>
<h1 id="组件"><a class="markdownIt-Anchor" href="#组件"></a> 组件</h1>
<p><a name="vIiCq"></a></p>
<h2 id="序列化"><a class="markdownIt-Anchor" href="#序列化"></a> 序列化</h2>
<p>这块没什么好说的，主要实现对不同的数据格式序列化和反序列化操作。<br />
<a name="iz0ul"></a></p>
<h3 id="json"><a class="markdownIt-Anchor" href="#json"></a> JSON</h3>
<p>特殊提一下json的默认序列化工具有一个小问题，序列化和反序列化时会识别是否为proto.Message，而使用proto自带的json序列化器，看代码可以发现，只断言了结构体对象，会导致如果为proto.Message数组时，无法正常使用proto的json序列化。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(codec)</span></span> Marshal(v <span class="keyword">interface</span>&#123;&#125;) ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> m := v.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> json.Marshaler:</span><br><span class="line">        <span class="keyword">return</span> m.MarshalJSON()</span><br><span class="line">        <span class="keyword">case</span> proto.Message:</span><br><span class="line">        <span class="keyword">return</span> MarshalOptions.Marshal(m)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> json.Marshal(m)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="xQ5ul"></a></p>
<h3 id="接口"><a class="markdownIt-Anchor" href="#接口"></a> 接口</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Codec <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Marshal returns the wire format of v.</span></span><br><span class="line">    Marshal(v <span class="keyword">interface</span>&#123;&#125;) ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br><span class="line">    <span class="comment">// Unmarshal parses the wire format into v.</span></span><br><span class="line">    Unmarshal(data []<span class="type">byte</span>, v <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span></span><br><span class="line">    <span class="comment">// Name returns the name of the Codec implementation. The returned string</span></span><br><span class="line">    <span class="comment">// will be used as part of content type in transmission.  The result must be</span></span><br><span class="line">    <span class="comment">// static; the result cannot change between calls.</span></span><br><span class="line">    Name() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="gOIyj"></a></p>
<h3 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意全局序列化器，aw中遇到默认json解析器无法正常识别protobuf数组数据时，就是通过覆盖json序列化器来实现替换的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterCodec</span><span class="params">(codec Codec)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> codec == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;cannot register a nil Codec&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> codec.Name() == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;cannot register Codec with empty string result for Name()&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    contentSubtype := strings.ToLower(codec.Name())</span><br><span class="line">    registeredCodecs[contentSubtype] = codec</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一个序列化器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetCodec</span><span class="params">(contentSubtype <span class="type">string</span>)</span></span> Codec &#123;</span><br><span class="line">    <span class="keyword">return</span> registeredCodecs[contentSubtype]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="wkQV5"></a></p>
<h2 id="元数据"><a class="markdownIt-Anchor" href="#元数据"></a> 元数据</h2>
<p>客户端和服务端开启</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端</span></span><br><span class="line">http.Middleware(</span><br><span class="line">    metadata.Server(),</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line">grpc.WithMiddleware(</span><br><span class="line">    metadata.Client()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>先来看服务端的实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Server is middleware server-side metadata.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Server</span><span class="params">(opts ...Option)</span></span> middleware.Middleware &#123;</span><br><span class="line">    <span class="comment">// 这边定义了元数据传递的前缀，非这个前缀的数据不会被接收</span></span><br><span class="line">    options := &amp;options&#123;</span><br><span class="line">        prefix: []<span class="type">string</span>&#123;<span class="string">&quot;x-md-&quot;</span>&#125;, <span class="comment">// x-md-global-, x-md-local</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, o := <span class="keyword">range</span> opts &#123;</span><br><span class="line">        o(options)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(handler middleware.Handler)</span></span> middleware.Handler &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;)</span></span> (reply <span class="keyword">interface</span>&#123;&#125;, err <span class="type">error</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> tr, ok := transport.FromServerContext(ctx); ok &#123;</span><br><span class="line">                md := options.md.Clone()</span><br><span class="line">                header := tr.RequestHeader()</span><br><span class="line">                <span class="comment">// 从请求头中取出所有的符合前缀的数据到元数据中</span></span><br><span class="line">                <span class="keyword">for</span> _, k := <span class="keyword">range</span> header.Keys() &#123;</span><br><span class="line">                    <span class="keyword">if</span> options.hasPrefix(k) &#123;</span><br><span class="line">                        md.Set(k, header.Get(k))</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ctx = metadata.NewServerContext(ctx, md)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> handler(ctx, req)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看客户端的实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Client is middleware client-side metadata.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Client</span><span class="params">(opts ...Option)</span></span> middleware.Middleware &#123;</span><br><span class="line">    <span class="comment">// 同样定义的传递的前缀，这个前缀只会用在service上的元数据</span></span><br><span class="line">    options := &amp;options&#123;</span><br><span class="line">        prefix: []<span class="type">string</span>&#123;<span class="string">&quot;x-md-global-&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, o := <span class="keyword">range</span> opts &#123;</span><br><span class="line">        o(options)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(handler middleware.Handler)</span></span> middleware.Handler &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;)</span></span> (reply <span class="keyword">interface</span>&#123;&#125;, err <span class="type">error</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> tr, ok := transport.FromClientContext(ctx); ok &#123;</span><br><span class="line">                header := tr.RequestHeader()</span><br><span class="line">                <span class="comment">// x-md-local-</span></span><br><span class="line">                <span class="comment">// 本地的元数据，初始化中间件的时候传入，可以放入服务版本号，服务名，服务权重之类的信息，每次client请求都会带上</span></span><br><span class="line">                <span class="keyword">for</span> k, v := <span class="keyword">range</span> options.md &#123;</span><br><span class="line">                    header.Set(k, v)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// client的元数据，使用时需要业务主动NewClientContext创建一个包含client的元数据上下文</span></span><br><span class="line">                <span class="keyword">if</span> md, ok := metadata.FromClientContext(ctx); ok &#123;</span><br><span class="line">                    <span class="keyword">for</span> k, v := <span class="keyword">range</span> md &#123;</span><br><span class="line">                        header.Set(k, v)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 服务器中的元数据信息，可以看到只有被定义成x-md-global的元数据才会被全局传递</span></span><br><span class="line">                <span class="comment">// x-md-local只会被传递一次</span></span><br><span class="line">                <span class="keyword">if</span> md, ok := metadata.FromServerContext(ctx); ok &#123;</span><br><span class="line">                    <span class="keyword">for</span> k, v := <span class="keyword">range</span> md &#123;</span><br><span class="line">                        <span class="keyword">if</span> options.hasPrefix(k) &#123;</span><br><span class="line">                            header.Set(k, v)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> handler(ctx, req)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看下使用例子，全局传递用户信息</p>
<ol>
<li>首先最基本的需要在service和client中打开元数据的中间件，就不贴代码了</li>
<li>注入全局元数据</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 鉴权中间件中</span></span><br><span class="line"><span class="comment">// 注入元数据传递，这种方式有并发安全问题</span></span><br><span class="line"><span class="keyword">if</span> md, ok := metadata.FromServerContext(ctx); ok &#123;</span><br><span class="line">    <span class="comment">// 不可能err</span></span><br><span class="line">    userByte, _ := json.Marshal(user)</span><br><span class="line">    md.Set(userMetadataKey, <span class="type">string</span>(userByte))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者，这种是安全的</span></span><br><span class="line">ctx = metadata.AppendToClientContext(ctx, userMetadataKey, <span class="type">string</span>(userByte))</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>提取元数据</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserFromMetaDataContext</span><span class="params">(ctx context.Context)</span></span> *User &#123;</span><br><span class="line">    <span class="keyword">if</span> md, ok := metadata.FromServerContext(ctx); ok &#123;</span><br><span class="line">        userStr := md.Get(userMetadataKey)</span><br><span class="line">        <span class="keyword">if</span> userStr != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            user := User&#123;&#125;</span><br><span class="line">            err := json.Unmarshal([]<span class="type">byte</span>(userStr), &amp;user)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Errorf(<span class="string">&quot;user metadata Unmarshal fail err(%+v)&quot;</span>, err)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> &amp;user</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="GKKay"></a></p>
<h2 id="错误处理"><a class="markdownIt-Anchor" href="#错误处理"></a> 错误处理</h2>
<p><a name="yU9NM"></a></p>
<h1 id="奇奇怪怪的算法"><a class="markdownIt-Anchor" href="#奇奇怪怪的算法"></a> 奇奇怪怪的算法</h1>
<p><a name="OJxna"></a></p>
<h2 id="负载均衡算法-p2c"><a class="markdownIt-Anchor" href="#负载均衡算法-p2c"></a> 负载均衡算法 P2C</h2>
<p>论文：<a target="_blank" rel="noopener" href="http://www.eecs.harvard.edu/~michaelm/NEWWORK/postscripts/twosurvey.pdf">《The Power of Two Random Choices: A Survey of Techniques and Results》</a> 两次随机选择<br />实现：</p>
<ol>
<li>从可用节点列表中做 2 次随机选择，得到节点 nodeA、nodeB</li>
<li>比较 nodeA、nodeB 两个节点，选出负载最低（kratos中主要使用正在处理的请求数，延迟，健康度（请求成功率）来加权计算）的节点作为被选中的节点</li>
</ol>
<p>代码：没什么好说的，就随机选两个，比较权重</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Balancer)</span></span> Pick(ctx context.Context, nodes []selector.WeightedNode) (selector.WeightedNode, selector.DoneFunc, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nodes) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, selector.ErrNoAvailable</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nodes) == <span class="number">1</span> &#123;</span><br><span class="line">        done := nodes[<span class="number">0</span>].Pick()</span><br><span class="line">        <span class="keyword">return</span> nodes[<span class="number">0</span>], done, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> pc, upc selector.WeightedNode</span><br><span class="line">    nodeA, nodeB := s.prePick(nodes)</span><br><span class="line">    <span class="comment">// meta.Weight is the weight set by the service publisher in discovery</span></span><br><span class="line">    <span class="keyword">if</span> nodeB.Weight() &gt; nodeA.Weight() &#123;</span><br><span class="line">        pc, upc = nodeB, nodeA</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pc, upc = nodeA, nodeB</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里有一个强制选择的动作，如果有一个节点长期没有被选中过，那就让他强制选中一次，来更新节点的状态（健康度等等）</span></span><br><span class="line">    <span class="comment">// If the failed node has never been selected once during forceGap, it is forced to be selected once</span></span><br><span class="line">    <span class="comment">// Take advantage of forced opportunities to trigger updates of success rate and delay</span></span><br><span class="line">    <span class="keyword">if</span> upc.PickElapsed() &gt; forcePick &amp;&amp; atomic.CompareAndSwapInt64(&amp;s.picked, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        pc = upc</span><br><span class="line">        atomic.StoreInt64(&amp;s.picked, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    done := pc.Pick()</span><br><span class="line">    <span class="keyword">return</span> pc, done, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点：依赖随机所有节点都有机会被调度到，通过多个节点随机调度，可以避免羊群效应。<br />
<a name="g6dE9"></a></p>
<h2 id="负载均衡算法-wrr"><a class="markdownIt-Anchor" href="#负载均衡算法-wrr"></a> 负载均衡算法 WRR</h2>
<p>加权轮询<br />假设abc三个节点权重5，1，1<br />bad：{c, b, a, a, a, a, a} 分布不均匀，连续请求<br />good：{a, a, b, a, c, a, a} 分布均匀<br />比较简单直接上代码吧</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Balancer)</span></span> Pick(_ context.Context, nodes []selector.WeightedNode) (selector.WeightedNode, selector.DoneFunc, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nodes) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, selector.ErrNoAvailable</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> totalWeight <span class="type">float64</span></span><br><span class="line">    <span class="keyword">var</span> selected selector.WeightedNode</span><br><span class="line">    <span class="keyword">var</span> selectWeight <span class="type">float64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// nginx wrr load balancing algorithm: http://blog.csdn.net/zhangskd/article/details/50194069</span></span><br><span class="line">    p.mu.Lock()</span><br><span class="line">    <span class="keyword">for</span> _, node := <span class="keyword">range</span> nodes &#123;</span><br><span class="line">        <span class="comment">// 每次遍历所有的权重，计算权重总值total，每次遍历对于每个节点当前权重都会加上节点权重值</span></span><br><span class="line">        totalWeight += node.Weight()</span><br><span class="line">        cwt := p.currentWeight[node.Address()]</span><br><span class="line">        <span class="comment">// current += effectiveWeight</span></span><br><span class="line">        cwt += node.Weight()</span><br><span class="line">        p.currentWeight[node.Address()] = cwt</span><br><span class="line">        <span class="keyword">if</span> selected == <span class="literal">nil</span> || selectWeight &lt; cwt &#123;</span><br><span class="line">            selectWeight = cwt</span><br><span class="line">            selected = node</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 经过上面权重的选择，选出权重值最大的一个节点，选出的这个节点减去所有节点权重的总值total</span></span><br><span class="line">    <span class="comment">// 理论上经过一轮之后全部都会恢复到0值，并且分布均匀，选中一次之后权重就会下降，其他节点机会更高</span></span><br><span class="line">    p.currentWeight[selected.Address()] = selectWeight - totalWeight</span><br><span class="line">    p.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    d := selected.Pick()</span><br><span class="line">    <span class="keyword">return</span> selected, d, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="Hjl9M"></a></p>
<h1 id="细节补充"><a class="markdownIt-Anchor" href="#细节补充"></a> 细节补充</h1>
<p><a name="gKVaA"></a></p>
<h2 id="超时传递"><a class="markdownIt-Anchor" href="#超时传递"></a> 超时传递</h2>
<p>一开始还以为是kratos实现的，其实是grpc实现的<br />依赖grpc -&gt; http2 实现的超时传递<br />在http2中会放进去grpc-timeout的header，server会取出来处理<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/1487474/1691816746464-30d0cccd-f958-422a-bc88-8f48deeb32fa.png#averageHue=%232d2d2c&amp;clientId=u59b681d6-7a1d-4&amp;from=paste&amp;id=u2b677981&amp;originHeight=476&amp;originWidth=1682&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1e535603-38fd-4eec-86ab-0ce10cc8a8b&amp;title=" alt="" /><br />那如果是http client是不是就不会传递了呢？没错！，kratos没有处理<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/1487474/1691816746406-f828b076-b676-43e7-9863-3003cdf57939.png#averageHue=%232f2c2c&amp;clientId=u59b681d6-7a1d-4&amp;from=paste&amp;id=u81bb93e4&amp;originHeight=988&amp;originWidth=2076&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u41f2f3a6-467a-49af-a7f6-2400ebf1fdd&amp;title=" alt="" /><br />
<a name="ycDg4"></a></p>
<h2 id="负载均衡节点信息采集"><a class="markdownIt-Anchor" href="#负载均衡节点信息采集"></a> 负载均衡节点信息采集</h2>
<p><a name="yXczu"></a></p>
<h3 id="节点信息从哪来"><a class="markdownIt-Anchor" href="#节点信息从哪来"></a> 节点信息从哪来</h3>
<ol>
<li>服务注册组件会持续更新节点信息</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/1487474/1691816746453-64bea59d-718f-4cdc-a02a-8d8787e21640.png#averageHue=%232d2c2b&amp;clientId=u59b681d6-7a1d-4&amp;from=paste&amp;id=u528f54d4&amp;originHeight=1256&amp;originWidth=1738&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u105863a3-5316-43bd-bb95-33137fd9fae&amp;title=" alt="" /></p>
<ol>
<li>grpc 创建负载均衡器时传入的节点信息（节点状态变更时会重新build，具体可以看Build的调用方）</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/1487474/1691816746401-94ec88fd-6a8b-4374-be20-892158806613.png#averageHue=%23302d2c&amp;clientId=u59b681d6-7a1d-4&amp;from=paste&amp;id=u0a28a0fe&amp;originHeight=778&amp;originWidth=1870&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ua3543dff-5829-4890-8bf5-f4da423623f&amp;title=" alt="" /><br />
<a name="jm37N"></a></p>
<h3 id="负载均衡节点信息结构"><a class="markdownIt-Anchor" href="#负载均衡节点信息结构"></a> 负载均衡节点信息结构</h3>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/1487474/1691816747439-3c0997ff-15ff-4839-ba0c-24a123d291c1.png#averageHue=%233e4654&amp;clientId=u59b681d6-7a1d-4&amp;from=paste&amp;id=uf0314f0e&amp;originHeight=380&amp;originWidth=718&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc941a4fa-94c2-46f8-8517-593c7587986&amp;title=" alt="" /></p>
<ol>
<li><strong>direct</strong></li>
</ol>
<p>这个比较简单，固定权重，权重信息在一开始服务初始化的使用用元数据注入进去，需要开启服务注册的功能才会传递元数据<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/1487474/1691816747487-987b3a3e-bbc1-47e6-822e-2b07fa97ccdb.png#averageHue=%23302d2c&amp;clientId=u59b681d6-7a1d-4&amp;from=paste&amp;id=u428a2d05&amp;originHeight=556&amp;originWidth=1302&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u210bb887-23af-439f-ac86-bc74855ac8c&amp;title=" alt="" /><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/1487474/1691816747572-5d4d1f91-aaba-4f5e-b2eb-841d821197ff.png#averageHue=%232f2c2b&amp;clientId=u59b681d6-7a1d-4&amp;from=paste&amp;id=u2b4ead7e&amp;originHeight=716&amp;originWidth=1504&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2ad47b97-9abc-4b4a-9887-e59031eef04&amp;title=" alt="" /></p>
<ol>
<li><strong>ewma</strong></li>
</ol>
<p>指数加权移动平均数，里面计算了几个值的ewma，主要包含健康度，正在处理的请求数，延迟（kratos1.0实现里面还带有cpu信息）</p>
<ul>
<li>先介绍两个常量值</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    <span class="comment">// The mean lifetime of `cost`, it reaches its half-life after Tau*ln(2).</span></span><br><span class="line">    <span class="comment">//  和半衰期相关的系数</span></span><br><span class="line">    tau = <span class="type">int64</span>(time.Millisecond * <span class="number">600</span>)</span><br><span class="line">    <span class="comment">// 惩罚值，刚加入的节点，给一个比较大的惩罚值，慢慢放流</span></span><br><span class="line">    penalty = <span class="type">uint64</span>(time.Second * <span class="number">10</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>初始化的默认值</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Build create a weighted node.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span></span> Build(n selector.Node) selector.WeightedNode &#123;</span><br><span class="line">    s := &amp;Node&#123;</span><br><span class="line">        Node:       n,</span><br><span class="line">        lag:        <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// 默认100</span></span><br><span class="line">        success:    <span class="number">1000</span>,</span><br><span class="line">        <span class="comment">// 为什么是1呢！！！！保证分母不为0</span></span><br><span class="line">        inflight:   <span class="number">1</span>,</span><br><span class="line">        <span class="comment">// 请求列表，主要存放请求开始时间，用来请求延时</span></span><br><span class="line">        inflights:  list.New(),</span><br><span class="line">        errHandler: b.ErrHandler,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>节点信息计算</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span></span> Pick() selector.DoneFunc &#123;</span><br><span class="line">    now := time.Now().UnixNano()</span><br><span class="line">    <span class="comment">// 更新最后被选中的时间</span></span><br><span class="line">    atomic.StoreInt64(&amp;n.lastPick, now)</span><br><span class="line">    <span class="comment">// 正在处理的请求+1</span></span><br><span class="line">    atomic.AddInt64(&amp;n.inflight, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 累计请求数+1</span></span><br><span class="line">    atomic.AddInt64(&amp;n.reqs, <span class="number">1</span>)</span><br><span class="line">    n.lk.Lock()</span><br><span class="line">    e := n.inflights.PushBack(now)</span><br><span class="line">    n.lk.Unlock()</span><br><span class="line">    <span class="comment">// 执行结束之后会回调这个方法，完成一些信息更新</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, di selector.DoneInfo)</span></span> &#123;</span><br><span class="line">        n.lk.Lock()</span><br><span class="line">        n.inflights.Remove(e)</span><br><span class="line">        n.lk.Unlock()</span><br><span class="line">        atomic.AddInt64(&amp;n.inflight, <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        now := time.Now().UnixNano()</span><br><span class="line">        <span class="comment">// get moving average ratio w</span></span><br><span class="line">        stamp := atomic.SwapInt64(&amp;n.stamp, now)</span><br><span class="line">        td := now - stamp</span><br><span class="line">        <span class="keyword">if</span> td &lt; <span class="number">0</span> &#123;</span><br><span class="line">            td = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 衰减值，越近的数据影响越大，越早的数据权重越低</span></span><br><span class="line">        w := math.Exp(<span class="type">float64</span>(-td) / <span class="type">float64</span>(tau))</span><br><span class="line"></span><br><span class="line">        start := e.Value.(<span class="type">int64</span>)</span><br><span class="line">        lag := now - start</span><br><span class="line">        <span class="keyword">if</span> lag &lt; <span class="number">0</span> &#123;</span><br><span class="line">            lag = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        oldLag := atomic.LoadInt64(&amp;n.lag)</span><br><span class="line">        <span class="keyword">if</span> oldLag == <span class="number">0</span> &#123;</span><br><span class="line">            w = <span class="number">0.0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 耗时计算，使用ewma</span></span><br><span class="line">        lag = <span class="type">int64</span>(<span class="type">float64</span>(oldLag)*w + <span class="type">float64</span>(lag)*(<span class="number">1.0</span>-w))</span><br><span class="line">        atomic.StoreInt64(&amp;n.lag, lag)</span><br><span class="line"></span><br><span class="line">        success := <span class="type">uint64</span>(<span class="number">1000</span>) <span class="comment">// error value ,if error set 1</span></span><br><span class="line">        <span class="keyword">if</span> di.Err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> n.errHandler != <span class="literal">nil</span> &amp;&amp; n.errHandler(di.Err) &#123;</span><br><span class="line">                success = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> netErr net.Error</span><br><span class="line">            <span class="keyword">if</span> errors.Is(context.DeadlineExceeded, di.Err) || errors.Is(context.Canceled, di.Err) ||</span><br><span class="line">            errors.IsServiceUnavailable(di.Err) || errors.IsGatewayTimeout(di.Err) || errors.As(di.Err, &amp;netErr) &#123;</span><br><span class="line">                success = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        oldSuc := atomic.LoadUint64(&amp;n.success)</span><br><span class="line">        <span class="comment">// 成功率计算，也是用ewma</span></span><br><span class="line">        success = <span class="type">uint64</span>(<span class="type">float64</span>(oldSuc)*w + <span class="type">float64</span>(success)*(<span class="number">1.0</span>-w))</span><br><span class="line">        atomic.StoreUint64(&amp;n.success, success)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>负载计算</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span></span> load() (load <span class="type">uint64</span>) &#123;</span><br><span class="line">    now := time.Now().UnixNano()</span><br><span class="line">    avgLag := atomic.LoadInt64(&amp;n.lag)</span><br><span class="line">    lastPredictTs := atomic.LoadInt64(&amp;n.predictTs)</span><br><span class="line">    predictInterval := avgLag / <span class="number">5</span> <span class="comment">// 窗口</span></span><br><span class="line">    <span class="comment">// 限制预测区间为5ms-200ms</span></span><br><span class="line">    <span class="keyword">if</span> predictInterval &lt; <span class="type">int64</span>(time.Millisecond*<span class="number">5</span>) &#123;</span><br><span class="line">        predictInterval = <span class="type">int64</span>(time.Millisecond * <span class="number">5</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> predictInterval &gt; <span class="type">int64</span>(time.Millisecond*<span class="number">200</span>) &#123;</span><br><span class="line">        predictInterval = <span class="type">int64</span>(time.Millisecond * <span class="number">200</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前距离上一次预测超过预期间隔，且cas成功，则更新一次预测</span></span><br><span class="line">    <span class="keyword">if</span> now-lastPredictTs &gt; predictInterval &amp;&amp; atomic.CompareAndSwapInt64(&amp;n.predictTs, lastPredictTs, now) &#123;</span><br><span class="line">        <span class="keyword">var</span> (</span><br><span class="line">            total   <span class="type">int64</span></span><br><span class="line">            count   <span class="type">int</span></span><br><span class="line">            predict <span class="type">int64</span></span><br><span class="line">        )</span><br><span class="line">        n.lk.RLock()</span><br><span class="line">        first := n.inflights.Front()</span><br><span class="line">        <span class="keyword">for</span> first != <span class="literal">nil</span> &#123;</span><br><span class="line">            lag := now - first.Value.(<span class="type">int64</span>)</span><br><span class="line">            <span class="keyword">if</span> lag &gt; avgLag &#123;</span><br><span class="line">                count++</span><br><span class="line">                total += lag</span><br><span class="line">            &#125;</span><br><span class="line">            first = first.Next()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只有一半以上节点超过平均耗时才更新预测值？</span></span><br><span class="line">        <span class="keyword">if</span> count &gt; (n.inflights.Len()/<span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">            predict = total / <span class="type">int64</span>(count)</span><br><span class="line">        &#125;</span><br><span class="line">        n.lk.RUnlock()</span><br><span class="line">        atomic.StoreInt64(&amp;n.predict, predict)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> avgLag == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// penalty is the penalty value when there is no data when the node is just started.</span></span><br><span class="line">        <span class="comment">// The default value is 1e9 * 10</span></span><br><span class="line">        <span class="comment">// 节点刚启动，没有请求过，给个很大的惩罚值</span></span><br><span class="line">        load = penalty * <span class="type">uint64</span>(atomic.LoadInt64(&amp;n.inflight))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取预测值，如果预测值比平均值大，更换</span></span><br><span class="line">    predict := atomic.LoadInt64(&amp;n.predict)</span><br><span class="line">    <span class="keyword">if</span> predict &gt; avgLag &#123;</span><br><span class="line">        avgLag = predict</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 负载=平均延迟*正在处理的请求数</span></span><br><span class="line">    load = <span class="type">uint64</span>(avgLag) * <span class="type">uint64</span>(atomic.LoadInt64(&amp;n.inflight))</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>权重计算</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Weight is node effective weight.</span></span><br><span class="line"><span class="comment">// 对权重有积极影响的放分子，健康度（健康度越高越好），反之放分母即负载（负载包含正在处理的请求数，耗时）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span></span> Weight() (weight <span class="type">float64</span>) &#123;</span><br><span class="line">    weight = <span class="type">float64</span>(n.health()*<span class="type">uint64</span>(time.Second)) / <span class="type">float64</span>(n.load())</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>思考题</li>
</ul>
<p>predict是为了解决什么问题的？<br />
<a name="CJA2D"></a></p>
<h1 id="其他参考资料"><a class="markdownIt-Anchor" href="#其他参考资料"></a> 其他参考资料</h1>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/OAjcQdQxQzTRRv6q52JPNg">https://mp.weixin.qq.com/s/OAjcQdQxQzTRRv6q52JPNg</a><br /><a target="_blank" rel="noopener" href="https://github.com/go-kratos/kratos/blob/v1.0.x/pkg/net/rpc/warden/balancer/p2c/p2c.go">https://github.com/go-kratos/kratos/blob/v1.0.x/pkg/net/rpc/warden/balancer/p2c/p2c.go</a><br /><a target="_blank" rel="noopener" href="https://pandaychen.github.io/2020/07/25/KRATOS-WARDEN-BALANCER-P2C-ANALYSIS/">https://pandaychen.github.io/2020/07/25/KRATOS-WARDEN-BALANCER-P2C-ANALYSIS/</a><br /><a target="_blank" rel="noopener" href="https://blog.naaln.com/2019/08/newton-law-cooling/">https://blog.naaln.com/2019/08/newton-law-cooling/</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/08/12/2023-05-05-actor%E6%A8%A1%E5%9E%8B/">No title</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-08-12</time><div class="content"><p><a name="OD3pj"></a></p>
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<p>Carl Hewitt 在1973年对Actor模型进行了如下定义：“Actor模型是一个把’Actor’作为并发计算的通用原语”. 在Actor模型中一切都是Actor，所有逻辑或模块都可以看成是Actor，通过不同Actor之间的消息传递实现模块之间的通信和交互。<br />它体现了三件事：</p>
<ul>
<li>信息处理（计算）</li>
<li>存储（状态）</li>
<li>通信</li>
</ul>
<p>from wiki</p>
<blockquote>
<p>The actor model in <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Computer_science">computer science</a> is a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Mathematical_model">mathematical model</a> of <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Concurrent_computation">concurrent computation</a> that treats an actor as the basic building block of concurrent computation. In response to a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Message_(computing)">message</a> it receives, an actor can: make local decisions, create more actors, send more messages, and determine how to respond to the next message received. Actors may modify their own <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Private_state">private state</a>, but can only affect each other indirectly through messaging (removing the need for <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Lock_(computer_science)">lock-based synchronization</a>).</p>
</blockquote>
<p><a name="sxsqH"></a></p>
<h2 id="actor模型"><a class="markdownIt-Anchor" href="#actor模型"></a> Actor模型</h2>
<p>一般来说，有两种策略用来在并发中进行通信：共享数据、消息传递。在传统并发模型中，使用共享内存是倾向于强一致性弱隔离性的，例如悲观锁同步的方式就是使用强一致性的方式控制并发。而Actor则是使用后者，Actor模型天然是强隔离性且弱一致性的，所以Actor模型在并发中有良好的性能，而且易于控制和管理。可以见得，Actor更适合一致性要求不高，但性能要求较高的场景下。</p>
<p>Actor系统由多个Actor组成，Actor是计算的<strong>基本单元</strong>，由以下三者组成：</p>
<ul>
<li>状态（state）：状态是指actor对象的变量信息，状态由actor自身管理，避免并发环境下的锁和内存原子性等问题。<strong>状态不可能被变其他actoc所改变</strong>。</li>
<li>行为（behavior）：行为指定的是actor中计算逻辑，通过actor接收到的消息来改变actor的状态。</li>
<li>邮箱（mailbox）：邮箱是actor之间的通信桥梁，邮箱内部通过FIFO消息队列来存储发送发消息，而接收方则从邮箱中获取消息。（邮箱也是Actor）</li>
</ul>
<p>简单来说大概长这样</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Actor <span class="keyword">struct</span> &#123;</span><br><span class="line">	state <span class="type">int</span></span><br><span class="line">    mailbox []Message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Actor)</span></span> send() &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Actor)</span></span> recive(m Message) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Actor接收到消息之后，他可以执行以下操作中的任意一件：</p>
<ul>
<li>创建更多Actor</li>
<li>向其他Actor发送消息</li>
<li>指定如何处理下一条消息（意味着可以定义它收到的下一条消息的状态如何。更明确地说，就是Actor如何修改状态。）</li>
</ul>
<p>尽管多个Actor同时运行，但是每个Actor只能顺序地处理消息，可以理解为每个actor都是单线程顺序执行接收到的message（即无共享状态，不用考虑锁）。在一个系统中可以把大规模任务分解成数个小任务，这些小任务可以由多个actor并发处理，从而最大化actor系统的性能。<br />一个简单的Actor模型系统：<br /><img src="https://cdn.nlark.com/yuque/0/2023/webp/1487474/1688259300627-fab6c035-8a5b-4aba-a2e4-231df3fc1b7d.webp#averageHue=%23000000&amp;clientId=u383e6f47-b6ce-4&amp;from=paste&amp;id=u2bcac10b&amp;originHeight=376&amp;originWidth=604&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u8aa2e16b-c1d0-4c20-876c-e7c6e4848a6&amp;title=" alt="" /></p>
<p>在Actor系统中包含一个未处理的任务集，每个任务都由三个属性标识：</p>
<ul>
<li>tag用以区分系统中的其他任务</li>
<li>target 通信到达的地址（接收消息的actor称为target）</li>
<li>communication 包含在target目标地址上的Actor，处理任务时可获取的信息。</li>
</ul>
<p>为简单起见，可见一个任务视为一个消息，在Actor之间传递包含以上三个属性的值的消息。</p>
<p>每个actor 都有 地址（address）。在各种实现中，地址可以是直接物理地址，例如MAC 地址、内存地址或仅仅是进程标识符 （PID）。 多个 actor 可以有相同的地址，一个 actor 可以有多个地址。 这里有一个多对多的关系。 地址不是 actor 的唯一标识符。 Actor没有身份，只有地址。 我们对地址所能做的就是向它发送消息。Actor 可以向自己发送消息（递归支持），他们将在以后的步骤中接收和处理这些消息。</p>
<p>Actor模型中存在两个局部性公理 ，包括<strong>组织性公理（Organisational）</strong> 和 <strong>操作性公理（Operational）</strong>。<br /><strong>操作</strong>: <br />响应收到的消息，Actor 只能：</p>
<ul>
<li>产生有限数量的新 actor。</li>
<li>仅将消息发送到刚刚收到的消息中的地址或其本地存储中的地址。</li>
<li>为下一条消息更新其本地存储（指定如何处理下一条消息）</li>
</ul>
<p><strong>组织</strong>：<br />Actor 的本地存储包括的地址<strong>只能是</strong>：</p>
<ul>
<li>在创建时提供的</li>
<li>在消息中收到的</li>
<li>适用于此处创建的 Actors（操作公理的第 1 段）</li>
</ul>
<p>Actor 模型没有为消息传递和处理提供许多保证（这些具体实现都是可扩展的，交给实现方，akka就由多种消息交付等级）。消息传递没有顺序保证，并且可以丢弃消息（例如，如果在发送信使之前 Actor 被销毁），因此我们有尽最大努力的传递。 消息可以持久化（Actor 定义的第 2 段： storage）并且可以重新发送。 消息最多可以传递 一次（一次或零次）。快速到达的消息可能会导致 actor 出现某种拒绝服务，从而使 actor 无法处理传入的消息流。 为了缓解这个问题，存在一个邮箱actor 接收消息并持有这些消息，直到 actor 能够处理它们。 消息可能需要任意长的时间才能最终到达接收方的邮箱。 在 Actor 模型的物理实现中，邮箱中消息的入队和出队是原子操作，因此不可能出现争用情况。<br />
<a name="SoZQs"></a></p>
<h2 id="容错"><a class="markdownIt-Anchor" href="#容错"></a> 容错</h2>
<p>Erlang 引入了「随它崩溃」的哲学理念，这部分关键代码被监控着，监控者的唯一职责是知道代码崩溃后干什么（如将这个单元代码重置为正常状态），让这种理念成为可能的正是actor模型。<br />每段代码都运行在process中，process是erlang称呼actor的方式。这个process完全独立，意味着它的状态不会影响其他process。我们有个supervisor，实际上它只是另一个process（所有东西都是actor），当被监控的process挂了，supervisor这个process会被通知并对此进行处理。这就让我们能创建「自愈」系统了。如果一个actor到达异常状态并崩溃，无论如何，supervisor都可以做出反应并尝试把它变成一致状态，这里有很多策略，最常见的是根据初始状态重启actor。<br />
<a name="rwuSz"></a></p>
<h2 id="csp-vs-actor"><a class="markdownIt-Anchor" href="#csp-vs-actor"></a> CSP vs Actor</h2>
<p>两种模型都基于消息传递：发送者发送消息，接收者获取消息。在这两种模型中，接收器都是同步的：当它准备好侦听消息时，它会阻塞直到收到消息（尽管变体允许它们进行非阻塞轮询或超时）。<br />CSP 是完全同步的。通道写入器必须阻塞，直到通道读取器读取。这种基于阻塞的机制的优点是通道只需要保存一条消息。从很多方面来说，它也更容易推理。<br />对于 Actor 来说，发送是异步的。无论读者是否准备好从邮箱中提取消息，消息发送者都不会阻塞，而是将消息放入通常称为“邮箱”的队列中。这很方便，但有点难以推理，而且邮箱可能必须保存大量消息。<br />CSP有一定相互依赖关系，可能出现死锁，开发人员必须意识到这一点并编写代码，以便消除死锁。<br />CSP 使用通道进行消息传递，而参与者使用邮箱。<br />Actor 只能通过消息传递进行通信，因此使它们成为无状态的。<br />Actor 模型是为分布式程序设计的，因此它可以跨多台机器进行扩展。而CSP只能在一台计算机中工作。<br />Actor 模型比 CSP 更加解耦。<br />
<a name="xFIDR"></a></p>
<h2 id="actor的不足之处"><a class="markdownIt-Anchor" href="#actor的不足之处"></a> Actor的不足之处</h2>
<ul>
<li>虽然比线程与锁模型更容易debug，但也会碰到actor模型独有的问题（eg:邮箱溢出）；由于actor模型不共享状态，仅通过消息传递来进行交流，所以不太适合实施细粒度的并行。</li>
<li>针对一致性要求比较强的场景比较乏力。（例如银行扣款，当用户A Actor扣款期间，用户B Actor是不受限的，此时对用户B Actor进行操作是合法的）</li>
<li>Actor 完全依赖于永远不会耗尽内存的无限输入缓冲区但这并不能保证。Actor没有能力拒绝交流。当消息到达时，必须对其进行处理，或者可能将其放入缓冲区中以供稍后处理。<br />
<a name="LDJ4u"></a></li>
</ul>
<h2 id="引用以及扩展阅读"><a class="markdownIt-Anchor" href="#引用以及扩展阅读"></a> 引用以及扩展阅读</h2>
<p><a target="_blank" rel="noopener" href="https://dl.acm.org/doi/10.5555/1624775.1624804">https://dl.acm.org/doi/10.5555/1624775.1624804</a><br /><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=7erJ1DV_Tlo">https://www.youtube.com/watch?v=7erJ1DV_Tlo</a><br /><a target="_blank" rel="noopener" href="https://alex-karaberov.medium.com/everything-you-always-wanted-to-know-about-the-actor-model-but-were-afraid-to-ask-b6eee8722953">https://alex-karaberov.medium.com/everything-you-always-wanted-to-know-about-the-actor-model-but-were-afraid-to-ask-b6eee8722953</a><br /><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d803e2a7de8e">https://www.jianshu.com/p/d803e2a7de8e</a><br /><a target="_blank" rel="noopener" href="https://github.com/asynkron/protoactor-go">https://github.com/asynkron/protoactor-go</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/08/12/2022-09-09-MySQL%20SQL%20Modes%E4%B8%8D%E5%90%8C%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98/">No title</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-08-12</time><div class="content"><p><a name="dAAlN"></a></p>
<h1 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h1>
<p>在正式环境一些操作发生SQL错误，测试环境没有发生。<br />
<a name="uvhjN"></a></p>
<h1 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h1>
<p><strong>问题SQL分析</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/1487474/1691839383030-f2f893df-dea2-4133-92fc-43880b07ea7e.png#averageHue=%23dce7f7&amp;clientId=u18125c63-f26c-4&amp;from=paste&amp;height=102&amp;id=u80f99333&amp;originHeight=153&amp;originWidth=2264&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=131568&amp;status=done&amp;style=none&amp;taskId=u719f6931-9369-44b3-b8f4-fa4d12b100c&amp;title=&amp;width=1509.3333333333333" alt="image.png" /><br />注意红色部分，updated_at类型是timestamp。<br />在<strong>非严格模式</strong>（strict SQL mode）下。2022-09-08 18:51:33.440657832 +0800 CST m=+58.128185931，实际有效的是2022-09-08 18:51:33，会按照这串进行插入，类型的 2022-09-08 18:51:33abc（2022-09-08 18:51:33），2022-09-08 18:51:abc（2022-09-08 18:51:00），abc（0000-00-00 00:00:00）都能正常插入。<br />在<strong>严格模式</strong>下则非法的值会直接产生报错。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1487474/1663411282574-d6bc4eb4-f38f-4da5-a7eb-da633be1caac.png#averageHue=%23f5f5f5&amp;clientId=u23088e99-4efc-4&amp;from=paste&amp;id=u8718bd3f&amp;originHeight=1356&amp;originWidth=2096&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uaaabfef3-194b-4a4e-b094-b9121365351&amp;title=" alt="" /><br /><strong>测试环境MySQL sql-mode</strong><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1487474/1663411282525-579c0220-76b6-4d91-a2a2-c25cd037ad09.png#averageHue=%23fbfbfa&amp;clientId=u23088e99-4efc-4&amp;from=paste&amp;id=u63f555ef&amp;originHeight=364&amp;originWidth=1240&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uc3346639-6b43-48d4-a850-2eeb6b35291&amp;title=" alt="" /><br /><strong>正式环境MySQL sql-mode</strong><br /><img src="https://cdn.nlark.com/yuque/0/2023/png/1487474/1691839341277-95c6405d-837c-4f56-961c-a641f06bc9fb.png#averageHue=%23f9f9f9&amp;clientId=u18125c63-f26c-4&amp;from=paste&amp;height=185&amp;id=u057a7249&amp;originHeight=278&amp;originWidth=1608&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=64446&amp;status=done&amp;style=none&amp;taskId=u5ea11478-8853-41c5-982b-e877dbbc338&amp;title=&amp;width=1072" alt="image.png" /><br />关注红色部分，在事务引擎开启了严格模式<br />
<a name="DzvUG"></a></p>
<h1 id="其他扩展"><a class="markdownIt-Anchor" href="#其他扩展"></a> 其他扩展</h1>
<ul>
<li>非严格模式下，对部分约束也不会进行报错，例如，列入某列<strong>NOT NULL</strong>且无默认值，当插入时未设置该值，仍然可以插入成功，并被设置类型的一个默认值；字符串<strong>超出长度</strong>会被自动截断。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1487474/1663411282500-0868dedc-959c-4b34-aa7f-e7f3f87aa135.png#averageHue=%23f8f8f8&amp;clientId=u23088e99-4efc-4&amp;from=paste&amp;id=u60489caf&amp;originHeight=614&amp;originWidth=2082&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ud74593b3-47c3-40e0-9ca1-1afe3eabfb8&amp;title=" alt="" /></p>
<ul>
<li>ONLY_FULL_GROUP_BY。这个配置应该比较常见，禁止select列，having条件或order by列表引用引用非聚合列的查询。</li>
</ul>
<p>更多相关可以参考资料中的官方文档。<br />
<a name="Qqi9u"></a></p>
<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<p>建议还是统一开启严格模式，减少奇形怪状的SQL，且环境统一。<br />
<a name="KBYYq"></a></p>
<h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1>
<p>官方文档：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html#sqlmode_strict_trans_tables">https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html#sqlmode_strict_trans_tables</a><br />
<a name="O3DFa"></a></p>
<h1 id="测试sql"><a class="markdownIt-Anchor" href="#测试sql"></a> 测试SQL</h1>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@SESSION</span>.SQL_MODE;</span><br><span class="line"><span class="keyword">SET</span> SESSION sql_mode <span class="operator">=</span> <span class="string">&#x27;STRICT_TRANS_TABLES&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@SESSION</span>.SQL_MODE;</span><br><span class="line"><span class="keyword">update</span> XXX <span class="keyword">set</span> updated_at <span class="operator">=</span> <span class="string">&#x27;2022-09-08 18:51a&#x27;</span>, updater_user <span class="operator">=</span> <span class="string">&#x27;XXX&#x27;</span> , updater_id <span class="operator">=</span> <span class="string">&#x27;XXX&#x27;</span> ,sort <span class="operator">=</span> <span class="keyword">case</span> id  <span class="keyword">when</span> <span class="number">338</span> <span class="keyword">then</span> <span class="number">100000</span> <span class="keyword">when</span> <span class="number">298</span> <span class="keyword">then</span> <span class="number">100001</span> <span class="keyword">when</span> <span class="number">330</span> <span class="keyword">then</span> <span class="number">100002</span> <span class="keyword">when</span> <span class="number">328</span> <span class="keyword">then</span> <span class="number">100003</span> <span class="keyword">end</span> <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="number">338</span>,<span class="number">298</span>,<span class="number">330</span>,<span class="number">328</span>);</span><br><span class="line"><span class="keyword">SELECT</span> updated_at <span class="keyword">FROM</span> XXX <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="number">338</span>,<span class="number">298</span>,<span class="number">330</span>,<span class="number">328</span>);</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/08/12/2022-06-17-%E4%BD%BF%E7%94%A8GoLand%E8%B0%83%E8%AF%95%E7%BC%96%E8%AF%91/">No title</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-08-12</time><div class="content"><p><a name="sFQfD"></a></p>
<h3 id="1编译go"><a class="markdownIt-Anchor" href="#1编译go"></a> 1.编译Go</h3>
<p>调试编译代码首先需要编译一个devel版本的go，clone<a target="_blank" rel="noopener" href="https://github.com/golang/go/tree/master/src">代码</a>，执行make即可<br />
<a name="b8Qgk"></a></p>
<h3 id="2设置goroot"><a class="markdownIt-Anchor" href="#2设置goroot"></a> 2.设置GOROOT</h3>
<p>设置为刚才编译的go<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1487474/1641261293769-16a4c9fc-ae67-47c4-82f4-dcea6b5517e6.png#clientId=u8a2b5a93-5b0f-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=380&amp;id=u4c9c1802&amp;originHeight=380&amp;originWidth=647&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=53596&amp;status=error&amp;style=none&amp;taskId=u8cf56679-8015-479d-a4f7-a940bdcd95e&amp;title=&amp;width=647" alt="image.png" /><br />
<a name="wL8VM"></a></p>
<h3 id="3进入编译入口代码"><a class="markdownIt-Anchor" href="#3进入编译入口代码"></a> 3.进入编译入口代码</h3>
<p>编译的入口代码在go/src/cmd/compile/main.go下<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1487474/1641261433364-f40b70a4-ae1d-44d4-8300-bb09ff9649bc.png#clientId=u8a2b5a93-5b0f-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=457&amp;id=ua1899015&amp;originHeight=457&amp;originWidth=1378&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=96670&amp;status=error&amp;style=none&amp;taskId=ua12f1086-b4f2-4ed1-b889-c603d778fe8&amp;title=&amp;width=1378" alt="image.png" /><br />
<a name="T1YMZ"></a></p>
<h3 id="4打断点运行开始调试"><a class="markdownIt-Anchor" href="#4打断点运行开始调试"></a> 4.打断点运行开始调试</h3>
<p>参数设置文件路径即可<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/1487474/1641261474441-56d008ce-ec53-4764-879c-64d047db12a3.png#clientId=u8a2b5a93-5b0f-4&amp;errorMessage=unknown%20error&amp;from=paste&amp;height=406&amp;id=u0f78ce94&amp;originHeight=406&amp;originWidth=580&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=48802&amp;status=error&amp;style=none&amp;taskId=uaeed080f-f2fe-4d9d-a9a4-f0c025c4acf&amp;title=&amp;width=580" alt="image.png" /></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2023/06/12/2023-06-12-Go%E4%B8%8E%E6%B3%9B%E5%9E%8B/">Go与范型</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-06-12</time><div class="content"><meta name="referrer" content="no-referrer" />
<p>本文相关代码均<strong>基于Go1.18</strong><br />
<a name="DjwaJ"></a></p>
<h1 id="泛型实现"><a class="markdownIt-Anchor" href="#泛型实现"></a> 泛型实现</h1>
<p><a name="AZJRG"></a></p>
<h2 id="什么是泛型"><a class="markdownIt-Anchor" href="#什么是泛型"></a> 什么是泛型</h2>
<p>Form wiki</p>
<blockquote>
<p>Generic programming is a style of computer programming in which algorithms are written in terms of data types to-be-specified-later that are then instantiated when needed for specific types provided as parameters. This approach, pioneered by the ML programming language in 1973,[1][2] permits writing common functions or types that differ only in the set of types on which they operate when used, thus reducing duplicate code.</p>
</blockquote>
<p><a name="ZM0O7"></a></p>
<h2 id="实现泛型的方式"><a class="markdownIt-Anchor" href="#实现泛型的方式"></a> 实现泛型的方式</h2>
<p>编程语言实现泛型具体化（又名参数多态性指的是声明与定义函数、复合类型、变量时不指定其具体的类型，而把这部分类型作为参数使用，使得该定义对各种具体类型都适用。）的方法有很多，但我们主要关注下面几个方案。<br />
<a name="Vva8r"></a></p>
<h3 id="手动泛型"><a class="markdownIt-Anchor" href="#手动泛型"></a> 手动泛型</h3>
<p>所谓手动泛型，就是。。。纯手撸👋，在Go没有支持类型参数（Type Parameter）前，基本都是用这种形式来实现泛型。<br />
<a name="fwyYd"></a></p>
<h4 id="手动复制代码"><a class="markdownIt-Anchor" href="#手动复制代码"></a> 手动复制/代码</h4>
<p>经典动图，一图胜千言。<br />当然这种实现也有它的优势，例如：性能高，可读性高，不需要做额外的类型检查等。<br /><img src="https://cdn.nlark.com/yuque/0/2023/gif/1487474/1688552355211-3aa10c0f-781b-4c1a-a788-4b85d8580525.gif#averageHue=%23272822&amp;clientId=u2224d895-6427-4&amp;from=paste&amp;id=ud6ef66a4&amp;originHeight=588&amp;originWidth=545&amp;originalType=url&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u970932ed-da12-44c6-a1c4-7517649a71a&amp;title=" alt="" /><br />
<a name="DsPEw"></a></p>
<h4 id="类型断言反射"><a class="markdownIt-Anchor" href="#类型断言反射"></a> 类型断言/反射</h4>
<p>通过传入interface参数来实现参数化类型，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func min(a, b interface&#123;&#125;) bool &#123;</span><br><span class="line">   switch v1 := a.(type) &#123;</span><br><span class="line">   case int:</span><br><span class="line">      return v1 &lt; b.(int)</span><br><span class="line">   case int32:</span><br><span class="line">      return v1 &lt; b.(int32)</span><br><span class="line">   &#125;</span><br><span class="line">   return false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="WyzAB"></a></p>
<h4 id="指针"><a class="markdownIt-Anchor" href="#指针"></a> 指针</h4>
<p>在同样不支持泛型的C语言中，我们通过*Void类型指针手动计算位移地址来实现。例如：<br />
<a name="MUrgS"></a></p>
<h3 id="单态化"><a class="markdownIt-Anchor" href="#单态化"></a> 单态化</h3>
<p>进行单态化最直接的方法之一是多次复制代码以实现不同的类型具体化——将多态转换为具体函数。这可以提高运行时性能，但会产生编译时成本，并可能产生臃肿的二进制文件。它适用于像 Rust，C++和C#这样的语言。<br />
<a name="swMvA"></a></p>
<h3 id="类型擦除"><a class="markdownIt-Anchor" href="#类型擦除"></a> 类型擦除</h3>
<p>熟悉Java的都知道，Java 的泛型仅存在于源代码中，并且会在运行时动态类型擦除为Object。虽然代码不冗余并且节省了空间，但是拆箱与装箱操作会减慢执行速度。类型擦除也给Java的泛型带来了很多的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Generics_in_Java#Problems_with_type_erasure">限制</a>。<br />
<a name="wkr2s"></a></p>
<h3 id="装箱"><a class="markdownIt-Anchor" href="#装箱"></a> 装箱</h3>
<p>在装箱中，“值”被装箱并作为多态类型的引用传递，通常使用指针表，通常称为虚拟表。这就是Go的interface的实现方式。这通常会生成较小的二进制文件，并且需要较短的编译时间，但可能会影响运行时性能。<br />
<a name="uDk46"></a></p>
<h2 id="go的三种泛型实现提案"><a class="markdownIt-Anchor" href="#go的三种泛型实现提案"></a> Go的三种泛型实现提案</h2>
<p>Go的实现方式也算可以归到单态化一类中。Go团队针对泛型实现一共提出了三个方案分别是：字典，蜡印，GC shape。<br />
<a name="qc3eJ"></a></p>
<h3 id="字典"><a class="markdownIt-Anchor" href="#字典"></a> <a target="_blank" rel="noopener" href="https://github.com/golang/proposal/blob/master/design/generics-implementation-dictionaries.md">字典</a></h3>
<p>当为泛型函数生成代码的时候，会生成唯一的一块代码，并且会在参数列表中增加一个字典做参数。字典是描述参数化类型所采用的具体类型的一组信息。当然，它包括具体类型本身，但也包括派生信息。<br />但是处理这样的字典并不是一件容易的事，因为还需要考虑泛型类型、派生类型和潜在的子字典。<br />另一种选择则是在字典中包含每个函数调用的每个参数/返回值所需的偏移量f(有点类似C的泛型实现)。<br />此外，还有其他潜在的问题。例如，字典是否用数组实现，是否需要排序，字典是否允许递归或自引用，以及如何让底层寄存器轻松处理不同的数据类型，比例单态化性能会慢多少等等等等。<br />
<a name="rCruf"></a></p>
<h3 id="蜡印"><a class="markdownIt-Anchor" href="#蜡印"></a> <a target="_blank" rel="noopener" href="https://github.com/golang/proposal/blob/master/design/generics-implementation-stenciling.md">蜡印</a></h3>
<p>与上述字典相反。相同的泛型函数为每个实例化的类型参数生成一组独立的代码。<br />因为编译f时是不知道它的实例化类型的，只有在调用它时才知道它的实例化的类型，所以需要在调用时编译f。对于相同实例化类型的多个调用，同一个package下编译器可以识别出来是一样的，只生成一个代码就可以了，但是不同的package就不简单了，这些函数表标记为DUPOK,所以链接器会丢掉重复的函数实现。<br />显然，这种策略有两个缺点。首先，由于需要编译泛型函数多次，所以需要更多的编译时间。其次，因为对于同一个泛型函数，每种类型需要单独的一份编译的代码，如果类型非常多，编译的文件可能非常大，而且性能也比较差。<br />
<a name="feWxS"></a></p>
<h3 id="gc-shape"><a class="markdownIt-Anchor" href="#gc-shape"></a> <a target="_blank" rel="noopener" href="https://github.com/golang/proposal/blob/master/design/generics-implementation-gcshape.md">GC Shape</a>（混合）</h3>
<p>GC Shape可以被视为上述两者的混合。 什么是GC形状？ GC Shape 不是一般的数据类型，而是编译器中处理内存分配/垃圾收集的类型。包括它的大小、所需的对齐方式、以及类型哪些部分包含指针。 用一个例子来更好地解释。int、uint32、 和int32 在某些编译器中具有相同的底层实现。即初始化变量时占用相同数量的内存地址。 <br />在实现中，每个GC shape都会生成一组代码，每组代码都携带一个包含实例化类型信息的字典。因此，与第一种方案相比，它大大减少了模板代码量，并降低了处理字典中的派生类型和实例化类型的复杂度。 <br />然而，它也存在风险。与完全模板化相比，可以减少的代码量是不可控的，并且编译器事先不知道如何使用泛型。因此，一旦减少有限但字典复杂度增加，这似乎并不是个明智的选择。<br />
<a name="tqpuh"></a></p>
<h2 id="验证go泛型实现"><a class="markdownIt-Anchor" href="#验证go泛型实现"></a> 验证Go泛型实现</h2>
<p><a name="DfiDK"></a></p>
<h3 id="调用分析"><a class="markdownIt-Anchor" href="#调用分析"></a> 调用分析</h3>
<p>上面介绍了Go的三种泛型实现的提案，现在我们来通过检查二进制文件验证一下，到底使用了哪一种方案。<br />先来看一段代码：<br />然后我们通过lensm来看下汇编（记得关闭编译优化）<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/1487474/1688552355242-7ac28bb9-5a78-4e82-9898-903b3bfbbe7a.png#averageHue=%23f5e6d7&amp;clientId=u2224d895-6427-4&amp;from=paste&amp;id=u29046497&amp;originHeight=762&amp;originWidth=2786&amp;originalType=url&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u29a1929e-2fd3-4a49-851a-0d95f0834cd&amp;title=" alt="" /><br />可以看到foo(123)调用了main.foo[go.shape.int_0]，foo(“xiaodaniubi”)则调用了main.foo[go.shape.string_0]。<br />所有的shage都放入名为go.shape的内置包中。编译器还将类型参数索引包含到shape中。int shape的基础类型可能是go.shape.int_0或go.shape.int_1，具体取决于类型参数是用作第一个参数还是第二个参数。<br />此外，所有指针类型共享相同的GC shape，即<em>int和</em>string生成相同的代码并且不是单态的。对于interface来说也是如此。我们再看下面一段代码，来验证一下这个设想：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/1487474/1688552355292-08912ec7-e858-4be0-bdd0-294a85fba12a.png#averageHue=%23f0eebe&amp;clientId=u2224d895-6427-4&amp;from=paste&amp;id=u96ce5e0a&amp;originHeight=932&amp;originWidth=2776&amp;originalType=url&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u26c5021f-c824-4215-a098-e9edcf3efb0&amp;title=" alt="" /><br />可以注意到几个点：</p>
<ul>
<li>foo(&amp;a)和foo(&amp;b)使用了相同的shape，都是调用了main.foo[go.shape.*uint8_0]。</li>
<li>baz(&amp;Bar{})调用main.baz[go.shape.*uint8_0]。可以看到，Bar的main.baz并不是单态的，所有接口类型共享相同的GC Shape。</li>
</ul>
<p>通过上述代码，大致可以确认，Go使用的方式就是GC Shape，当然也可以Go提案中也明确了，使用了GC Share，可以参考：<a target="_blank" rel="noopener" href="https://github.com/golang/proposal/blob/master/design/generics-implementation-dictionaries-go1.18.md">https://github.com/golang/proposal/blob/master/design/generics-implementation-dictionaries-go1.18.md</a><br />
<a name="a4dlK"></a></p>
<h3 id="gc-share类型解析"><a class="markdownIt-Anchor" href="#gc-share类型解析"></a> GC Share类型解析</h3>
<p>那么相同的GC shape如何进行解析的呢？这时候就要用到前面说的提案一之字典了，细心的同学可能已经发送了，前面的汇编中有这样一段内容：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/1487474/1688552355202-79b3081c-2e2a-4d8d-9334-ee51eb286cc5.png#averageHue=%23c9dcea&amp;clientId=u2224d895-6427-4&amp;from=paste&amp;id=u462134a8&amp;originHeight=306&amp;originWidth=676&amp;originalType=url&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1e714f7e-f80e-4ea6-bbb5-eb99f59dc27&amp;title=" alt="" /><br />对于x86_64，可以看到字典被传递到AX寄存器中。Go 使用当前泛型实现将字典传递给被调用函数。该字典包含用于解析方法并将其与interface相互转换的所有元数据。<br />再看下方法的汇编：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/1487474/1688552355197-0f7d064b-94e9-4ebe-af75-5a227621007b.png#averageHue=%23f6f3f0&amp;clientId=u2224d895-6427-4&amp;from=paste&amp;id=u567cf057&amp;originHeight=1256&amp;originWidth=2558&amp;originalType=url&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u276ff6b6-2b39-4509-885c-22782c636f3&amp;title=" alt="" /><br />可以看到，在调用data.Stuff()之前，运行时使用寄存器AX中存储的字典解析函数地址。寄存器AX中会存储的字典解析函数地址。这类似于接口的“虚拟”方法调用的工作方式。<br />字典在编译时静态定义，并以泛型函数的完全限定名称和类型参数的名称命名。编译器会删除具有相同名称的字典的重复数据。<br />
<a name="qpgtJ"></a></p>
<h3 id="表现"><a class="markdownIt-Anchor" href="#表现"></a> 表现</h3>
<p>使用泛型重写基于接口的 API 可以提高性能，但由于使用字典进行方法解析，也有可能会损害性能。</p>
<ul>
<li>[ ] <strong>todo 未完待续</strong><a href="/ouwei-3zruh">@普通的咸鱼(ouwei-3zruh)</a><br />
<a name="v2gV3"></a></li>
</ul>
<h1 id="go泛型使用"><a class="markdownIt-Anchor" href="#go泛型使用"></a> Go泛型使用</h1>
<p><a name="FJMgZ"></a></p>
<h2 id="基本语法和使用"><a class="markdownIt-Anchor" href="#基本语法和使用"></a> 基本语法和使用</h2>
<p>泛型在Go语言中增加了三个新的重要内容：</p>
<ul>
<li>函数和类型新增对类型形参(type parameters)的支持。</li>
<li>将接口类型定义为类型集合，包括没有方法的接口类型。</li>
<li>支持类型推导，大多数情况下，调用泛型函数时可省略类型实参(type arguments)。</li>
</ul>
<p>函数和类型（<strong>目前还不支持</strong><a target="_blank" rel="noopener" href="https://github.com/golang/go/issues/49085"><strong>泛型方法</strong></a>）被允许拥有类型形参(Type Parameters)。一个类型形参列表看起来和普通的函数形参列表一样，只不过使用的是方括号而不是小括号。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GMin</span>[<span class="title">T</span> <span class="title">constraints</span>.<span class="title">Ordered</span>]<span class="params">(x, y T)</span></span> T &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	GMin[<span class="type">int</span>](<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">	GMin[<span class="type">int32</span>](<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也可以跟类型一起用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Tree[T any] <span class="keyword">struct</span> &#123;</span><br><span class="line">    left, right *Tree[T]</span><br><span class="line">    value       T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Tree[T])</span></span> Lookup(x T) *Tree[T] &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stringTree Tree[<span class="type">string</span>]</span><br></pre></td></tr></table></figure>
<p>泛型类型Tree存储了类型参数T的值。泛型类型也可以有方法。<br />
<a name="dgQqP"></a></p>
<h2 id="泛型约束"><a class="markdownIt-Anchor" href="#泛型约束"></a> 泛型约束</h2>
<p>我们再来看上面的min例子，了解一下为什么需要泛型约束。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GMin</span>[<span class="title">T</span> <span class="title">constraints</span>.<span class="title">Ordered</span>]<span class="params">(x, y T)</span></span> T &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意一下这个约束，<code>T constraints.Ordered</code>只有满足支持比较运算符的类型才可以使用这个泛型函数，如果没有泛型约束，自然就无法确定类型支持的方法了。<br />如果某类型约束不限制类型实现的函数，同时也不限制类型支持的运算符，那就意味着对应的类型参数可以接受任意类型。这种特殊的约束就是any（实际就是interface{}的别名，因为官方觉得interface{}又臭又长所以引入了个any）。<br />我们继续看一下刚才用到的<code>constraints.Ordered</code>的定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Ordered <span class="keyword">interface</span> &#123;</span><br><span class="line">    Integer|Float|~<span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ordered接口是所有整数、浮点和字符串类型的集合。竖线<code>|</code>表达了类型（或者说这里是类型集合）的联合(union)。Integer和Float是接口类型，在constraints包中也有类似的定义。注意，Ordered接口没有定义任何方法。<br />对于类型约束，我们通常不关心某一个特定的类型，比如字符串；我们对所有的字符串类型感兴趣。这就是<sub>标记的作用，称为近似约束。表达式</sub>string意味着底层类型(underlying type)为string的所有类型的集合。这包括string类型本身，以及所有用类似type MyString string声明的类型。<br />对于一些简单的使用场景，可以省略interface关键字。比如：<br /><code>type Max[T interface&#123;int|uint&#125;](a, b T) &#123; ... &#125;</code><br />可以直接简化成：<br /><code>type Max[T int|uint](a, b T) &#123; ... &#125;</code><br />
<a name="N7Drm"></a></p>
<h3 id="any约束"><a class="markdownIt-Anchor" href="#any约束"></a> any约束</h3>
<p>即对类型没有任务限制，我们在写代码的时候只能使用所有类型都支持的语法，类似java的Object：</p>
<ul>
<li>声明或者定义变量</li>
<li>同类型变量之前相互赋值</li>
<li>用作函数的参数或者返回值</li>
<li>获取对应变量的地址</li>
<li>将对应变量转换成interface{}或者赋值给interface{}类型的变量</li>
<li>将interface{}类型的变量转换成对应类型的变量: t, ok := v.(T)</li>
<li>在 switch 类型枚举使用对应类型: switch v.(type) { case T: /* … */ }</li>
<li>构造复合类型，比如 []T</li>
<li>传给某些内置函数，比如 p := new(T)<br />
<a name="aIdja"></a></li>
</ul>
<h3 id="函数约束"><a class="markdownIt-Anchor" href="#函数约束"></a> 函数约束</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo <span class="keyword">interface</span> &#123;</span><br><span class="line">    Baz() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们希望类型参数T所有的取值都实现Baz() string函数时，我们就可以像上面这样定义。<br />
<a name="dttQf"></a></p>
<h3 id="泛型约束-2"><a class="markdownIt-Anchor" href="#泛型约束-2"></a> 泛型约束</h3>
<p>约束也可以包含约束本身<br />
<a name="dvmjT"></a></p>
<h3 id="运算符约束"><a class="markdownIt-Anchor" href="#运算符约束"></a> 运算符约束</h3>
<p>Go语言不允许重载运算符。所以，只能Go语言内置的对象才支持运算符操作。要实现例如&gt;，&lt;等约束，只能通过包含所有可排序的类型进行约束，例如上面的<code>constraints.Ordered</code>，但是有一个特殊的内置约束类型是<code>comparable</code>代表了可比较类型（==，!=），具体哪些可比较可以参考：<a target="_blank" rel="noopener" href="https://go.dev/ref/spec#Comparison_operators">https://go.dev/ref/spec#Comparison_operators</a><br />
<a name="AhT9w"></a></p>
<h2 id="泛型推导"><a class="markdownIt-Anchor" href="#泛型推导"></a> 泛型推导</h2>
<p>最后一个主要的语言新特性是类型推导。在某些方面，这是语言最复杂的变化，但它很重要，因为它让人们在编写调用泛型函数的代码时使用一种更为自然的风格。<br />Go语言支持如下几种情况的类型推导：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Map 对入参 s 切片中的每个元素执行函数 f，将结果保存到新的切片并返回。</span><br><span class="line">// 类型参数 F 和 T 需要在调用的时候指定。</span><br><span class="line">func Map[F, T any](s []F, f func(F) T) []T &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">var s []int</span><br><span class="line">f := func(i int) int64 &#123; return int64(i) &#125;</span><br><span class="line">var r []int64</span><br><span class="line"></span><br><span class="line">// 普通情形，指定全部类型参数</span><br><span class="line">r = Map[int, int64](s, f)</span><br><span class="line"></span><br><span class="line">// 仅指定第一个类型参数，自动推导后面的类型参数</span><br><span class="line">r = Map[int](s, f)</span><br><span class="line"></span><br><span class="line">// 自动推导所有类型参数</span><br><span class="line">r = Map(s, f)</span><br></pre></td></tr></table></figure>
<p>如果在使用泛型函数/类型的时候未指明全部的类型参数，编译器就会尝试推导缺失的类型。如果推导失败则会报编译错误。<br />
<a name="n98t4"></a></p>
<h3 id="函数实参类型推导function-argument-type-inference"><a class="markdownIt-Anchor" href="#函数实参类型推导function-argument-type-inference"></a> 函数实参类型推导(Function argument type inference)</h3>
<p>以上面的自动推导例子来看，在许多情况下，编译器可以从普通参数中推导出T的类型实参。这使得代码更短。其原理是将实际参数a和b的类型与形式参数x和y的类型相匹配。这种从函数的实参类型推导出类型实参的推导方式，被称为<strong>函数实参类型推导</strong>。<br />推导分两个阶段。<br />第一段跳过所有实参中无类型常量匹配一遍。如果还有类型参数没有确定，则将开始第二阶段。此时需要给所有无类型常量设置为对应的默认类型，然后再匹配一遍。同一个类型参数可能被匹配多次，如果多次匹配的类型结果不一致就会报编译错误。<br />有类型参数上面已经看过了，来看一下无类型参数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Boo</span>[<span class="title">F</span> <span class="title">any</span>]<span class="params">(f1, f2 F)</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于<code>Boo(1, 2)</code>会跳过第一阶段，第二阶段给1和2设定默认类型为int。所以类型参数F对应int，该函数调用被推断为<code>Boo[int](1,2)</code>。</li>
<li>对于<code>Boo(1,int64(2))</code>，第一阶段推导忽略无类型常量1。因为第二个参数的类型为int64，所以推断F的参数为int64。所以最终的函数调用为<code>Boo[int64](1,2)</code></li>
<li><code>对于NewPair(1,2.5)</code>，第二阶段先将1和2.5设定默认类型为int和float64。然后从左往右匹配。对于参数1确认F为int，对于参数2.5，确定F为float64。两次结果不相同，所以报错。</li>
</ul>
<p>类型推导完成后，编译器依然会执行约束校验和参数类型检查。<br />
<a name="MSFaZ"></a></p>
<h3 id="约束类型推导constraint-type-inference"><a class="markdownIt-Anchor" href="#约束类型推导constraint-type-inference"></a> 约束类型推导(Constraint type inference)</h3>
<p>假设我们有如下函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MySlice []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(MySlice)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;MySlice&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Double</span>[<span class="title">E</span> <span class="title">constraints</span>.<span class="title">Number</span>]<span class="params">(s []E)</span></span> []E &#123;</span><br><span class="line">	r := <span class="built_in">make</span>([]E, <span class="built_in">len</span>(s))</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		r[i] = v + v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">type</span> MySlice []<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> v = Double(MySlice&#123;<span class="number">1</span>&#125;)</span><br><span class="line">v.String()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上面推导出来到的<code>v</code>的类型其实是<code>[]int</code>，而不是我们想要的<code>MySlice</code>。因为编译器在比较<code>MySlice</code>和<code>[]E</code>的时候把<code>MySlice</code>换成了底层类型<code>[]int</code>，所以推导出<code>E</code>为<code>int</code>。<br />为了能让Double正常返回MySlice类型，我们将函数改写成：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SC 限定类型必须为元素类型为 E 的切片。</span></span><br><span class="line"><span class="keyword">type</span> SC[E any] <span class="keyword">interface</span> &#123;</span><br><span class="line">	[]E</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoubleDefined</span>[<span class="title">S</span> <span class="title">SC</span>[<span class="title">E</span>], <span class="title">E</span> <span class="title">constraints</span>.<span class="title">Number</span>]<span class="params">(s S)</span></span> S &#123;</span><br><span class="line">	r := <span class="built_in">make</span>(S, <span class="built_in">len</span>(s))</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		r[i] = v + v</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">var</span> v1 = DoubleDefined[MySlice, <span class="type">int</span>](MySlice&#123;<span class="number">1</span>&#125;)</span><br><span class="line"><span class="comment">// 或者自动推导</span></span><br><span class="line"><span class="keyword">var</span> v2 = DoubleDefined(MySlice&#123;<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>首先，编译器执行函数参数类型推导。此时需要对比<code>MySlice</code>和<code>S</code>，但<code>S</code>使用结构约束，所以需要推导其实际的约束类型。<br />为此，编译器构建一个映射表：<br /><code>&#123;S -&gt; MySlice&#125;</code><br />然后，编译器展开<code>S</code>约束，把<code>SC[E]</code>展开成<code>[]E</code>。因为我们之前记录了<code>S</code>跟<code>MySlice</code>的映射关系，所以可以对比<code>[]E</code>和<code>MySlice</code>。又因为<code>MySlice</code>的底层类型为<code>[]int</code>，所以推导出<code>E</code>的类型为<code>int</code>：<br /><code>&#123;S -&gt; MySlice, E -&gt; int&#125;</code><br />然后，我们把约束中的<code>E</code>都换成<code>int</code>，看还有没有不确定的类型参数。没有了，所以推导结束。所以原来的调用被推导为：<br /><code>var v = DoubleDefined[MySlice,int](MySlice&#123;1&#125;)</code><br />返回的结果依然是<code>MySlice</code>。<br /><strong>指针方法约束示例</strong><br />假设我们希望把一组字符串转换成一组其他类型的数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Setter 限制类型需要实现 Set 方法，通过 string 设置自身的值。</span></span><br><span class="line"><span class="keyword">type</span> Setter <span class="keyword">interface</span> &#123;</span><br><span class="line">	Set(<span class="type">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FromStrings 接受字符串切片，返回类型为 T 的切片。</span></span><br><span class="line"><span class="comment">// 返回切片中每个元素的值通过调用其 Set 方法设置。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FromStrings</span>[<span class="title">T</span> <span class="title">Setter</span>]<span class="params">(s []<span class="type">string</span>)</span></span> []T &#123;</span><br><span class="line">	result := <span class="built_in">make</span>([]T, <span class="built_in">len</span>(s))</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		result[i].Set(v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Settable 是可以从字符串设置自身取值的整数类型。</span></span><br><span class="line"><span class="keyword">type</span> Settable <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Set 将字符串解析成整数并赋给 *p。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Settable)</span></span> Set(s <span class="type">string</span>) &#123;</span><br><span class="line">	i, _ := strconv.Atoi(s)</span><br><span class="line">	*p = Settable(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数，无法编译</span></span><br><span class="line">nums := FromStrings[Settable]([]<span class="type">string</span>&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>上面的代码不能正常编译。因为我们指定<code>T</code>的类型为<code>Settable</code>，但<code>Settable</code>类型并没有实现<code>Set(string)</code>方法。实现该方法的是类型<code>*Settable</code>。<br />于是我们将调用代码改成：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用函数，正常编译，但运行报错</span></span><br><span class="line">nums := FromStrings[*Settable]([]<span class="type">string</span>&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>这次可以正常编译，但运行代码又会报错。这是因为在<code>FromStrings</code>中，<code>result[i]</code>的类型为<code>*Settable</code>，值为<code>nil</code>，无法执行<code>*p = *Settable(i)</code>赋值。<br />所以说，上面定义的<code>FromStrings</code>，我们既不能将<code>T</code>定为<code>Settable</code>，这会导致编译错误，又不能定为<code>*Settable</code>，这会导致运行时错误。<br />为了实现<code>FromStrings</code>，我们需要同时指定<code>Settable</code>和<code>*Settable</code>类型，这就需要结构化约束：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Setter2 限制类型必须是 B 的指针而且要实现 Set 方法。</span></span><br><span class="line"><span class="keyword">type</span> Setter2[B any] <span class="keyword">interface</span> &#123;</span><br><span class="line">	Set(<span class="type">string</span>)</span><br><span class="line">	*B</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FromStrings2 接受字符串切片，返回 T 切片。</span></span><br><span class="line"><span class="comment">// 这里定义了两个类型参数，所以才能在返回 T 切片的同时</span></span><br><span class="line"><span class="comment">// 调用 *T 也就是 PT 的方法。</span></span><br><span class="line"><span class="comment">// Setter2 约束可以确保 PT 是 T 的指针。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FromStrings2</span>[<span class="title">T</span> <span class="title">any</span>, <span class="title">PT</span> <span class="title">Setter2</span>[<span class="title">T</span>]]<span class="params">(s []<span class="type">string</span>)</span></span> []T &#123;</span><br><span class="line">	result := <span class="built_in">make</span>([]T, <span class="built_in">len</span>(s))</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		<span class="comment">// &amp;result[i] 类型是 *T，也就是 Setter2 的类型。</span></span><br><span class="line">		<span class="comment">// 所以可以将其强转为 PT。</span></span><br><span class="line">		p := PT(&amp;result[i])</span><br><span class="line">		<span class="comment">// PT 实现了 Set 方法</span></span><br><span class="line">		p.Set(v)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用代码如下：</span></span><br><span class="line">nums := FromStrings2[Settable, *Settable]([]<span class="type">string</span>&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>&#125;)</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="comment">// 因为函数入参中没有使用 T，所以无法进一步简化</span></span><br><span class="line">nums := FromStrings2[Settable]([]<span class="type">string</span>&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>整个编译器的推导过程是这样的。首先，根据已知类型构造映射表：<br /><code>&#123;T -&gt; Settable&#125;</code><br />然后用<code>Settable</code>替换<code>T</code>，展开所有结构化参数。所以<code>PT</code>的类型<code>Setter2[T]</code>被展开成<code>*T</code>，加入到映射表：<br /><code>&#123;T -&gt; Settable, PT -&gt; *T&#125;</code><br />然后把所有<code>T</code>替换成<code>Settable</code>，最终得到：<br /><code>&#123;T -&gt; Settable, PT -&gt; *Settable&#125;</code><br />到此推导结束，实际的函数调用为<code>FromStrings2[Settable,*Settable]([]string&#123;&quot;1&quot;,&quot;2&quot;&#125;)</code>。<br />
<a name="xaGSc"></a></p>
<h1 id="关于go引入泛型的讨论"><a class="markdownIt-Anchor" href="#关于go引入泛型的讨论"></a> 关于Go引入泛型的讨论</h1>
<p><a name="xTIBY"></a></p>
<h1 id="扩展阅读"><a class="markdownIt-Anchor" href="#扩展阅读"></a> 扩展阅读</h1>
<p><a name="JUiS0"></a></p>
<h2 id="go-map实现"><a class="markdownIt-Anchor" href="#go-map实现"></a> Go map实现</h2>
<p>为什么要在泛型里提到Go map的实现呢，大家都知道Go map是可以接收不同类型的kv的，那在没有泛型的时候它是怎么实现的？（其实是懒得再起一篇了，就顺便简单介绍一下<br /><strong>Go运行时是否使用interface{}？</strong><br />不，Go 运行时不用于interface{}实现其map。虽然我们有container/{list,heap}使用空接口的包，但运行时的map实现不使用interface{}.<br /><strong>编译器是否使用代码生成？</strong><br />不，Go 二进制文件中只有一份map实现的副本。只有一种实现，并且与 Java 不同，它不使用interface{}装箱。那么它是怎样工作的？<br />答案有两个部分，它们都涉及编译器和运行时之间的合作。<br />
<a name="ldHxh"></a></p>
<h3 id="编译时重写"><a class="markdownIt-Anchor" href="#编译时重写"></a> 编译时重写</h3>
<p>在编译期间，map操作被重写为对运行时的调用。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v := m[<span class="string">&quot;key&quot;</span>] 	  <span class="comment">// runtime.mapaccess1(m, ”key&quot;, &amp;v)</span></span><br><span class="line">v, ok := m[<span class="string">&quot;key&quot;</span>] <span class="comment">// runtime.mapaccess2(m, ”key”, &amp;v, &amp;ok)</span></span><br><span class="line">m[<span class="string">&quot;key&quot;</span>] = <span class="number">9001</span>   <span class="comment">// runtime.mapinsert(m, ”key&quot;, 9001)</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">&quot;key&quot;</span>)  <span class="comment">// runtime.mapdelete(m, “key”)</span></span><br></pre></td></tr></table></figure>
<p>类似的实现还有chan，但是slice不是。<br />
<a name="P1g14"></a></p>
<h3 id="运行时调用"><a class="markdownIt-Anchor" href="#运行时调用"></a> 运行时调用</h3>
<p>说了编译期间，再来看看运行时不使用interface又是如何解析具体类型的。</p>
<blockquote>
<p>源码面前，了无秘密</p>
</blockquote>
<p>我们直接来看一下函数签名<code>runtime.mapaccess1</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccess1</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们看一下这些参数。</p>
<ul>
<li>key是一个指向键的指针。</li>
<li>h是一个指向runtime.hmap结构体的指针。hmap是运行时的hash结构，用于保存存储桶和其他hash信息</li>
<li>t是一个指向runtime.maptype结构的指针</li>
</ul>
<p>那么可以猜到，<em>maptype就是使</em>hmap适用于（几乎）键和值类型的任何组合的原因。maptype中每个唯一的映射声明都有一个值。将会有一个描述从strings到ints、从strings到http.Headers等的映射。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> maptype <span class="keyword">struct</span> &#123;</span><br><span class="line">	typ    _type</span><br><span class="line">	key    *_type</span><br><span class="line">	elem   *_type</span><br><span class="line">	bucket *_type <span class="comment">// internal type representing a hash bucket</span></span><br><span class="line">	<span class="comment">// function for hashing keys (ptr to key, seed) -&gt; hash</span></span><br><span class="line">	hasher     <span class="function"><span class="keyword">func</span><span class="params">(unsafe.Pointer, <span class="type">uintptr</span>)</span></span> <span class="type">uintptr</span></span><br><span class="line">	keysize    <span class="type">uint8</span>  <span class="comment">// size of key slot</span></span><br><span class="line">	elemsize   <span class="type">uint8</span>  <span class="comment">// size of elem slot</span></span><br><span class="line">	bucketsize <span class="type">uint16</span> <span class="comment">// size of bucket</span></span><br><span class="line">	flags      <span class="type">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个maptype都包含有关从key到elem的此类映射的属性的详细信息。它包含有关key和elem的信息。maptype.key包含有关我们传递的key的指针的信息。我们称这些为<strong>类型描述符</strong>。<br />到此为止，大概可以理解，为什么map可以处理几乎任意类型了，那就先点到为止，等下次写map分析时再具体展开说说吧。<br />
<a name="pZmFJ"></a></p>
<h1 id="结语"><a class="markdownIt-Anchor" href="#结语"></a> 结语</h1>
<blockquote>
<p>了解泛型的原理不一定会让你成为更好的开发人员，但它肯定会加深你对编程语言的理解。</p>
</blockquote>
<p>在编写参数多态代码时，Go 泛型是一个很好的补充。但通过了解泛型的具体实现，我们应该注意到，将接口作为类型参数传递给泛型函数会增加解析具体类型所需的查找次数，从而对性能产生不利影响。泛型的一个更好的用例是直接编写通用数据结构。消除了对接口类型的需求，并为许多优化打开了大门。<br />在泛型的实现中顺带提了一下map的多态实现，如果后面有时间再写一篇完整的map源码分析<br />
<a name="devUA"></a></p>
<h1 id="引用或延伸阅读"><a class="markdownIt-Anchor" href="#引用或延伸阅读"></a> 引用或延伸阅读</h1>
<p><a target="_blank" rel="noopener" href="https://github.com/golang/proposal/blob/master/design/generics-implementation-dictionaries-go1.18.md">https://github.com/golang/proposal/blob/master/design/generics-implementation-dictionaries-go1.18.md</a><br /><a target="_blank" rel="noopener" href="https://go.dev/ref/spec#Type_constraints">https://go.dev/ref/spec#Type_constraints</a><br /><a target="_blank" rel="noopener" href="https://go.dev/ref/spec#Comparison_operators">https://go.dev/ref/spec#Comparison_operators</a><br /><a target="_blank" rel="noopener" href="https://go.dev/blog/when-generics">https://go.dev/blog/when-generics</a><br /><a target="_blank" rel="noopener" href="https://go.dev/doc/tutorial/generics">https://go.dev/doc/tutorial/generics</a><br /><a target="_blank" rel="noopener" href="https://www.bmpi.dev/dev/deep-in-program-language/how-to-implement-generics/">https://www.bmpi.dev/dev/deep-in-program-language/how-to-implement-generics/</a><br /><a target="_blank" rel="noopener" href="https://deepsource.com/blog/go-1-18-generics-implementation">https://deepsource.com/blog/go-1-18-generics-implementation</a><br /><a target="_blank" rel="noopener" href="https://taoshu.in/go/generics/design.html#%E5%A4%8D%E5%90%88%E7%BA%A6%E6%9D%9F">https://taoshu.in/go/generics/design.html#%E5%A4%8D%E5%90%88%E7%BA%A6%E6%9D%9F</a><br /><a target="_blank" rel="noopener" href="https://medium.com/geekculture/go-generics-stories-behind-scenes-e520a43903">https://medium.com/geekculture/go-generics-stories-behind-scenes-e520a43903</a><br /><a target="_blank" rel="noopener" href="https://thume.ca/2019/07/14/a-tour-of-metaprogramming-models-for-generics/">https://thume.ca/2019/07/14/a-tour-of-metaprogramming-models-for-generics/</a><br /><a target="_blank" rel="noopener" href="https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics">https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics</a><br /><a target="_blank" rel="noopener" href="https://github.com/golang/proposal/blob/master/design/generics-implementation-dictionaries-go1.18.md">https://github.com/golang/proposal/blob/master/design/generics-implementation-dictionaries-go1.18.md</a><br /><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/xprmcl5qbf6yvdroajyn">https://www.infoq.cn/article/xprmcl5qbf6yvdroajyn</a><br /><a target="_blank" rel="noopener" href="https://go.dev/ref/spec">https://go.dev/ref/spec</a><br /><a target="_blank" rel="noopener" href="https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md">https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md</a><br />一个泛型库：<a target="_blank" rel="noopener" href="https://github.com/samber/lo">https://github.com/samber/lo</a></p>
</div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2023 By Fish</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>